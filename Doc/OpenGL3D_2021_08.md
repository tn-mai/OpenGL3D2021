[OpenGL 3D 2021 第08回]

# 

## 習得目標

* 普通のポインタを止めて、常にスマートポインタを使う
* キー入力によってキャラクターを動かす方法
* 描画に使うオブジェクトの管理

## 1. 削除の自動化

### 1.1 テクスチャの削除を自動化する

OpenGLのオブジェクトは、使い終わったら削除しなくてはなりません。しかし、プログラムがどんどん変わっていくような状況で、オブジェクトを削除するべきタイミングを手動で管理することは大変に難しい作業です。

そこでC++では、クラスのデストラクタで削除を行うことで、削除タイミングの管理を自動化します。既に`VBO`、`IBO`、`VAO`は、`PrimitiveBuffer`クラスが自動的に削除するようになっています。

ただ、テクスチャとサンプラはまだ自動的に削除するようになっていません。そこで、これらも削除を自動化しようと思います。

削除を自動化するために、テクスチャ・オブジェクトを管理するクラスを作ります。名前はストレートに`Texture`(テクスチャ)としましょう。テクスチャクラスは以下の機能を持ちます。

>1. 画像ファイル名からテクスチャを作成する。
>2. 作成の成功・失敗の確認。
>3. テクスチャを削除する。
>4. テクスチャをグラフィックスパイプラインにバインドする。
>5. グラフィックスパイプラインへのバインドを解除する。

1の「作成」はコンストラクタ、3の削除はデストラクタで行うのが適当でしょう。2, 4, 5はメンバ関数で行うことにします。

それでは、プロジェクトの`Src`フォルダに`Texture.h`というヘッダファイルを作成してください。そして、追加した`Texture.h`に次のプログラムを追加してください。

```diff
+/**
+* @file Texture.h
+*/
+#ifndef TEXTURE_H_INCLUDED
+#define TEXTURE_H_INCLUDED
+#include <glad/glad.h>
+#include "GLContext.h"
+#include <string>
+
+/**
+* テクスチャを管理するクラス.
+*/
+class Texture
+{
+public:
+  Texture(const char* filename); // コンストラクタ
+  ~Texture();                    // デストラクタ
+
+  // オブジェクトの有効性を判定する
+  bool IsValid() const;
+
+  // バインド管理
+  void Bind(GLuint unit) const;
+  void Unbind(GLuint unit) const;
+
+private:
+  std::string name; // 画像ファイル名
+  GLuint id = 0;    // オブジェクトID
+};
+
+#endif // TEXTURE_H_INCLUDED
```

### 1.2 コンストラクタを定義する

ソースファイルを追加し、メンバ関数を定義していきましょう。プロジェクトの`Src`フォルダに`Texture.cpp`というファイルを追加してください。追加したファイルを開き、次のプログラムを追加してください。

```diff
+/**
+* @file Texture.cpp
+*/
+#include "Texture.h"
+#include "GLContext.h"
+#include <iostream>
+
+/**
+* コンストラクタ.
+*
+* @param filename 画像ファイル名.
+*/
+Texture::Texture(const char* filename)
+{
+  id = GLContext::CreateImage2D(filename);
+  if (id) {
+    name = filename;
+    std::cout << "[情報]" << __func__ << "テクスチャ" << filename << "を作成.\n";
+  } else {
+    std::cout << "[エラー]" << __func__ << "テクスチャ" << filename << "の作成に失敗.\n";
+  }
+}
```

コンストラクタでは`CreateImage2D`関数を呼び出してテクスチャを作成します。次に作成結果に応じたデバッグ用のメッセージを出力します。

### 1.3 デストラクタを定義する

次にデストラクタを定義します。コンストラクタの定義の下に、次のプログラムを追加してください。

```diff
     std::cout << "[エラー]" << __func__ << "テクスチャ" << filename << "の作成に失敗.\n";
   }
 }
+
+/**
+* デストラクタ.
+*/
+Texture::~Texture()
+{
+  if (id) {
+    std::cout << "[情報]" << __func__ << "テクスチャ" << name << "を削除.\n";
+  }
+  glDeleteTextures(1, &id);
+}
```

### 1.4 <ruby>IsValid<rt>イズ・バリッド</rt></ruby>関数を定義する

`IsValid`(イズ・バリッド)は、`Texture`クラスが使用可能になっているかどうかを調べるメンバ関数です。デストラクタの定義の下に、次のプログラムを追加してください。

```diff
   }
   glDeleteTextures(1, &id);
 }
+
+/**
+* オブジェクトが使える状態かどうかを調べる.
+*
+* @retval true  使える.
+* @retval false 使えない(初期化に失敗している).
+*/
+bool Texture::IsValid() const
+{
+  return id;
+}
```

`ProgramPipeline`クラスの時にも説明しましたが、コンストラクタには戻り値がないため、初期化に成功したかどうかを判定できません。そこで判定用の関数を作り、コンストラクタの実行結果を調べられるようにしておきます。

コンストラクタで初期化に成功していれば、`id`(アイディー)変数には`0`以外の値が入っているはずです。`id`変数の値を`bool`型に変換して返せば、作成に成功したかどうかが分かります。

### 1.5 <ruby>Bind<rt>バインド</rt></ruby>関数を定義する

続いて、テクスチャ・オブジェクトを、グラフィックスパイプラインにバインドするメンバ関数を定義します。`IsValid`メンバ関数の定義の下に、次のプログラムを追加してください。

```diff
 {
   return id;
 }
+
+/**
+* テクスチャをグラフィックスパイプラインに割り当てる.
+*
+* @param unit 割り当てるテクスチャイメージユニットの番号.
+*/
+void Texture::Bind(GLuint unit) const
+{
+  glBindTextureUnit(unit, id);
+}
```

### 1.6 <ruby>Unbind<rt>アンバインド</rt></ruby>関数を定義する

最後に、バインドを解除するメンバ関数を定義します。`Bind`メンバ関数の定義の下に、次のプログラムを追加してください。

```diff
 {
   glBindTextureUnit(unit, id);
 }
+
+/**
+* テクスチャの割り当てを解除する.
+*
+* @param unit 割り当て解除するテクスチャイメージユニットの番号.
+*/
+void Texture::Unbind(GLuint unit) const
+{
+  glBindTextureUnit(unit, 0);
+}
```

これで`Texture`クラスの定義は完了です。

### 1.7 テクスチャ・オブジェクトをTextureクラスで置き換える

作成した`Texture`クラスで、`Main.cpp`のテクスチャ・オブジェクトを置き換えていきます。`Main.cpp`を開き、`ProgramPipeline.h`のインクルード文の下に、次のプログラムを追加してください。

```diff
 #include "Primitive.h"
 #include "ProgramPipeline.h"
+#include "Texture.h"
 #include <glm/gtc/matrix_transform.hpp>
 #include <GLFW/glfw3.h>
 #include <string>
```

>**【配列から作成しているテクスチャについて】**<br>
>まだTGAファイルにしていないテクスチャがある場合、全てTGAファイルから作成するようにプログラムを変更してから先へ進んでください。

次に、テクスチャ・オブジェクトを作成するプログラムを、次のように書き換えてください。

```diff
   // テクスチャを作成.
-  const GLuint texGround = GLContext::CreateImage2D("Res/Ground.tga");
-  const GLuint texTriangle = GLContext::CreateImage2D("Res/Triangle.tga");
-  const GLuint texGreen = GLContext::CreateImage2D("Res/Green.tga");
-  const GLuint texRoad = GLContext::CreateImage2D("Res/Road.tga");
-  const GLuint texTree = GLContext::CreateImage2D("Res/Tree.tga");
-  const GLuint texWarehouse = GLContext::CreateImage2D("Res/Warehouse.tga");
+  Texture texGround = Texture("Res/Ground.tga");
+  Texture texTriangle = Texture("Res/Triangle.tga");
+  Texture texGreen = Texture("Res/Green.tga");
+  Texture texRoad = Texture("Res/Road.tga");
+  Texture texTree = Texture("Res/Tree.tga");
+  Texture texWarehouse = Texture("Res/Warehouse.tga");
-  if (!texGround || !texTriangle || !texGreen || !texRoad || !texTree || !texWarehouse) {
-    return 1;
-  }

   // サンプラを作成.
   const GLuint sampler = GLContext::CreateSampler(GL_REPEAT);
```

作成に成功したかどうかの判定は削除することにしました。これまでは、テキストどおりに動くようにしたかったのでエラーチェックをしていたのですが、そろそろ無くしてもよい頃合いでしょう。

このエラーチェックを無くしても、コンソールウィンドウに出力されたメッセージを見ればエラーの有無は分かります。また、アプリのユーザーの視点に立った場合、テクスチャが表示されないことより、アプリが動作しないことのほうが問題だと考えられます。

### 1.8 テクスチャ・オブジェクトの後始末を消す

`Texture`クラスは、デストラクタが自動的にオブジェクトを削除しますので、手動の後始末を書く必要はありません。後始末プログラムを次のように書き換えてください。

```diff
   // 後始末.
   glDeleteSamplers(1, &sampler);
-  glDeleteTextures(1, &texWarehouse);
-  glDeleteTextures(1, &texTree);
-  glDeleteTextures(1, &texRoad);
-  glDeleteTextures(1, &texGreen);
-  glDeleteTextures(1, &texTriangle);
-  glDeleteTextures(1, &texGround);

   // GLFWの終了.
   glfwTerminate();
```

### 1.9 バインド方法を変更する

次に、`glBindTextureUnit`関数を、`Texture`クラスの`Bind`メンバ関数で置き換えます。テクスチャ・オブジェクトをバインドするプログラムを、以下のように書き換えてください。

```diff
     pipeline.SetUniform(locMatTRS, matMVP);
     pipeline.SetUniform(locMatModel, matModel);
 
-    glBindTextureUnit(0, texTriangle); // テクスチャを割り当てる.
+    texTriangle.Bind(0); // テクスチャを割り当てる.
     primitiveBuffer.Get(2).Draw();
     primitiveBuffer.Get(3).Draw();
```

続いて物体の表示データを修正します。`Texture`クラスのデストラクタが二重に起動することを防ぐため、変数のアドレス(または参照)を使います。これについては後で説明します。`ObjectData`構造体と`objectList`配列を次のように変更してください。

```diff
     // マップに配置する物体の表示データ.
     struct ObjectData {
       Primitive prim;
-      GLuint tex;
+      const Texture* tex;
     };

     // 描画する物体のリスト.
     const ObjectData objectList[] = {
       { Primitive(), 0 },    // なし
-      { primitiveBuffer.Get(4), texTree }, // 木
-      { primitiveBuffer.Get(5), texWarehouse }, // 建物
+      { primitiveBuffer.Get(4), &texTree }, // 木
+      { primitiveBuffer.Get(5), &texWarehouse }, // 建物
     };
```

`ObjectData`を使っているプログラムも修正します。テクスチャを割り当てるプログラムを次のように変更してください。

```diff
         pipeline.SetUniform(locMatTRS, matMVP);
         pipeline.SetUniform(locMatModel, matModel);

-        glBindTextureUnit(0, p.tex); // テクスチャを割り当てる.
+        p.tex->Bind(0); // テクスチャを割り当てる.
         p.prim.Draw();
       }
```

同様にして`mapTexList`配列も修正しましょう。`mapTexList`配列を次のように変更してください。

```diff
     // マップを(-20,-20)-(20,20)の範囲に描画.
-    const GLuint mapTexList[] = { texGreen, texGround, texRoad };
+    const Texture* mapTexList[] = { &texGreen, &texGround, &texRoad };
     for (int y = 0; y < 10; ++y) {
       for (int x = 0; x < 10; ++x) {
```

最後に`mapTexList`配列の要素をバインドするプログラムを、次のように変更してください。

```diff
         pipeline.SetUniform(locMatModel, matModel);
 
         const int textureNo = mapData[y][x];
-        glBindTextureUnit(0, mapTexList[textureNo]); // テクスチャを割り当てる.
+        mapTexList[textureNo]->Bind(0); // テクスチャを割り当てる.
         primitiveBuffer.Get(0).Draw();
       }
     }
```

これで、テクスチャ・オブジェクトを手動で管理する手間をなくせました。

<pre class="tnmai_assignment">
<strong>【課題01】</strong>
プロジェクトの<code>Src</code>フォルダに<code>Sampler.h</code>と<code>Sampler.cpp</code>というファイルを追加して、サンプラを管理する<code>Sampler</code>クラスを作成しなさい。
</pre>

<pre class="tnmai_assignment">
<strong>【課題02】</strong>
課題01で作成した<code>Sampler</code>クラスを使って、<code>main</code>関数にある<code>sampler</code>変数を置き換えなさい。
</pre>

>**【1章のまとめ】**<br>
>
>* クラスを使うと変数をまとめて管理することができる。
>* デストラクタでオブジェクトを削除すると、削除し忘れることを防げる。

<div style="page-break-after: always"></div>

## 2. スマートポインタによるオブジェクト管理

### 2.1 ポインタを使う理由

1章では、配置する物体や地面の模様を描画する時、`Texture`クラスの変数ではなく、変数のアドレスを使いました。もし変数をコピーしていたらどうなっていたでしょう。





`Texture`クラスの変数をコピーすると、テクスチャ・オブジェクトIDが格納されている`id`メンバ変数がコピーされます。そして、コピーした変数もデストラクタを実行します。

`texGreen`変数を`mapTexList[0]`に代入したとしましょう。C++言語の代入は「右辺の値を左辺にコピーする」という動作をします。また、OpenGLのオブジェクトは、オブジェクトを示す整数値で管理されます。

これらのことから、この時点で`texGreen`と`mapTexList[0]`の`id`メンバ変数には同じ整数値が代入された状態になります。

次に、「変数の有効期限は同じレベルの`}`まで」というC++のルールにより、`while`ループの終端で`mapTexList[0]`の有効期限が切れて削除されます。`mapTexList[0]`は`Texture`クラスの変数なので、`Texture`クラスのデストラクタが実行されます。

`Texture`クラスのデストラクタは、クラスが管理しているテクスチャ・オブジェクトを削除します。これによって`mapTexList[0]`が管理しているテクスチャ・オブジェクトが削除されます。

`texGreen`と`mapTexList[0]`の`id`メンバ変数の値は等しいので、`texGreen`の`id`メンバ変数はもうテクスチャを表しません。つまり、2回目以降の`while`ループではもはや`texGreen`はなんの役にも立たないのです。

それだけではありません。`main`関数が終了するときに`texGreen`のデストラクタが実行されるので、何も指していないIDを削除しようとしてエラーが発生します。このように、デストラクタと変数のコピーの組み合わせは、時にはやっかいな問題となることがあります。

実際に書いてもらったプログラムでは、この問題を避けるために「アドレス】を使っています。

「アドレス」は「変数の場所」を表現します。「場所」を表すという点では配列の「添え字」と同じです。しかし、添え字は「特定の配列の中の場所」を表すことしかできません。

それに対して、アドレスは「メモリ内のあらゆる場所」を表すことができます。アドレスは「メモリ全体を配列とする添え字」だと考えてもよいでしょう。

そして、アドレスを代入するための変数は「ポインタ」あるいは「ポインタ変数」と呼ばれます。

>**【アドレスとポインタ】**<br>
>ポインタ変数にはアドレスしか代入できないので、「ポインタ = アドレス」と考えても特に問題はありません。

ポインタを使う主な目的を以下に示します。

>* 同じ変数をプログラムの複数の場所で使いたい。
>* 関数の中で変数を書き換えたい。
>* メモリをコピーする量を減らしてプログラムの実行速度を上げたい。

### 2.2 スマートポインタ

ポインタの有用性はお分かり頂けたと思いますが、ポインタを使うことによって、次のような弊害もあります。

>1. ポインタの指している変数がいつまで有効なのか分からない。
>2. 通常の変数とポインタ変数で、メンバにアクセスするための演算子が違う。

特に1は多くのバグの原因となるため、非常にやっかいです。しかし、C++にはこの問題を解決するための「スマートポインタ」と呼ばれるクラス群が用意されています。

スマートポインタはデストラクタで自動的に`delete`を実行してくれるクラスの総称です。クラスですが、普通のポインタと同じ感覚で使えるように作られています。

現代のC++では、ほとんどの場合にスマートポインタが使われます。普通のポインタは危険なので極力避けます。今回は最も汎用的な機能を持つ`shared_ptr`(シェアード・ポインタ)クラスを使います。

シェアードポインタは自分のコピーがどれだけ作られたかを把握していて、まだコピーが残っているあいだは`delete`を実行しません。これによって、全てのシェアードポインタは有効な変数を指していることが保証されます。

シェアードポインタを含むスマートポインタクラスは、`memory`ヘッダに定義されています。`Main.cpp`を開き、次のプログラムを追加してください。

```diff
 #include <GLFW/glfw3.h>
 #include <string>
 #include <iostream>
+#include <memory>
 #pragma comment(lib, "opengl32.lib")
```

### 2.3 Textureをシェアードポインタで置き換える

次に`Texutre`クラスの変数をシェアードポインタで置き換えます。シェアードポインタは次のように書くことで「管理する型」のポインタになります。

<pre class="tnmai_code"><strong>【書式】</strong>
std::shared_ptr<管理する型>
</pre>

今回は使いませんが、配列を管理する場合は、型名の直後に配列を表す`[]`を付けて以下のように書きます。

<pre class="tnmai_code"><strong>【書式】</strong>
std::shared_ptr<管理する型[]>
</pre>

それでは、シェアードポインタを使ってみましょう。`Main.cpp`を開き、テクスチャを作成するプログラムを次のように変更してください。

```diff
   // テクスチャを作成.
-  Texture texGround = Texture("Res/Ground.tga");
-  Texture texTriangle = Texture("Res/Triangle.tga");
-  Texture texGreen = Texture("Res/Green.tga");
-  Texture texRoad = Texture("Res/Road.tga");
-  Texture texTree = Texture("Res/Tree.tga");
-  Texture texWarehouse = Texture("Res/Warehouse.tga");
+  std::shared_ptr<Texture> texGround(new Texture("Res/Ground.tga"));
+  std::shared_ptr<Texture> texTriangle(new Texture("Res/Triangle.tga"));
+  std::shared_ptr<Texture> texGreen(new Texture("Res/Green.tga"));
+  std::shared_ptr<Texture> texRoad(new Texture("Res/Road.tga"));
+  std::shared_ptr<Texture> texTree(new Texture("Res/Tree.tga"));
+  std::shared_ptr<Texture> texWarehouse(new Texture("Res/Warehouse.tga"));

   // サンプラを作成.
   const GLuint sampler = GLContext::CreateSampler(GL_REPEAT);
```

次に、`Texture`クラスの`Bind`メンバ関数の呼び出しを`.`から`->`に変更します。テクスチャ・オブジェクトをバインドするプログラムを、以下のように書き換えてください。

```diff
     pipeline.SetUniform(locMatTRS, matMVP);
     pipeline.SetUniform(locMatModel, matModel);
 
-    texTriangle.Bind(0); // テクスチャを割り当てる.
+    texTriangle->Bind(0); // テクスチャを割り当てる.
     primitiveBuffer.Get(2).Draw();
     primitiveBuffer.Get(3).Draw();
```

続いて物体の表示データを修正します。`ObjectData`構造体と`objectList`配列を次のように変更してください。

```diff
     // マップに配置する物体の表示データ.
     struct ObjectData {
       Primitive prim;
-      const Texture* tex;
+      const std::shared_ptr<Texture> tex;
     };

     // 描画する物体のリスト.
     const ObjectData objectList[] = {
       { Primitive(), 0 },    // なし
-      { primitiveBuffer.Get(4), &texTree }, // 木
-      { primitiveBuffer.Get(5), &texWarehouse }, // 建物
+      { primitiveBuffer.Get(4), texTree }, // 木
+      { primitiveBuffer.Get(5), texWarehouse }, // 建物
     };
```

`texTree`、`texWarehouse`をポインタ変数にしたので、もう`&`でアドレスを求める必要はありません。

<pre class="tnmai_assignment">
<strong>【課題03】</strong>
<code>objectList</code>配列を参考にして、<code>mapTexList</code>配列をシェアードポインタを使うように修正しなさい。
</pre>

<pre class="tnmai_assignment">
<strong>【課題04】</strong>
<code>Sampler</code>クラスの変数を、スマートポインタで管理するようにプログラムを変更しなさい。
</pre>

>**【2章のまとめ】**<br>
>
>* 
>* 

<div style="page-break-after: always"></div>

## 3. OBJファイル読み取り機能の強化

### 3.1 インターネットからOBJファイルを取得する

曲がりなりにもOBJファイルを読み込めるようになったので、無料のOBJファイルをダウンロードして読み込んでみましょう。ウェブブラウザで以下のサイトにアクセスしてください。

`https://free3d.com/ja/`

すると次のような画面が表示されます。

<p align="center">
<img src="images/08_free3d_00.png" width="50%" />
</p>

画面中央上部にある検索ボックスに「戦車」と入力して`Enter`キーを押してください。すると戦車の検索結果が表示されます。

<p align="center">
<img src="images/08_free3d_01.png" width="66%" />
</p>

わたしたちが読み込めるのはOBJファイル形式だけなので、ファイル形式の中から「obj」をクリックします。すると、OBJファイル形式でダウンロードできるデータだけが表示されます。

今回は左上の「タイガーI重戦車」をダウンロードします。「タイガーI重戦車」の画像をクリックしてください。するとデータの詳細が表示されます。

<p align="center">
<img src="images/08_free3d_02.png" width="33%" />
</p>

この画面で「ダウンロード」ボタンをクリックすると、画面上部に次のような小さなウィンドウが開きます。

<p align="center">
<img src="images/08_free3d_03.png" width="50%" />
</p>

ファイル名の下に、ファイルに含まれるデータ形式が表示されていますので、「obj」が含まれるファイルを選択します。このデータにはファイルがひとつしかないので選択の余地はありませんが。

なお、大抵のデータは圧縮されていますので、何らかのアプリで展開する必要があります。タイガーI戦車の場合はrar(ラー)形式で圧縮されています。ただ、Windowsの標準機能ではrar形式を展開できません。

既に7-ZipやWinRARなどのアプリをインストールしている場合は、それを使って展開してください。展開アプリをインストールした記憶がない場合は、以下のサイトから64ビット版の`7-zip`(セブン・ジップ)というアプリをダウンロードしてインストールしてください。

`https://sevenzip.osdn.jp/`

### 3.2 画像ファイルをTGA形式に変換する

ダウンロードしたrarファイルを展開すると、以下のファイルが現れると思います。

>* Additional.txt
>* PzVI_Tiger_I_NM.dds
>* PzVI_Tiger_I_SM.dds
>* PzVI_Tiger_I_track.dds
>* PzVI_Tiger_I_track_NM.dds
>* PzVI_Tiger_I_track_SM.dds
>* PzVI_Tiger_I.dds
>* Tiger_I.3ds
>* Tiger_I.blend
>* Tiger_I.mtl
>* Tiger_I.obj

一番下の「Tiger_I.obj」がOBJファイルです。末尾が`dds`となっているのは画像ファイルです。しかし、現在のわたしたちはTGA形式の画像しか扱えません。そこで、Visual Studioを使ってDDS形式をTGA形式に変換します。

「PzVI_Tiger_I.dds」をエクスプローラーからVisual Studioの編集ウィンドウにドラッグ&ドロップするか、Visual Studioのメニューから「ファイル→開く→ファイル」を選択して開きます。

すると、プロパティウィンドウには次のように表示されていると思います(プロパティウィンドウが開いていない場合は画像ウィンドウ上部の「スパナアイコン」をクリック)。

<p align="center">
<img src="images/08_dds_to_tga_00.png" width="33%" />
</p>

プロパティの「形式」欄は`DXGI_FORMAT_BC1_UNORM`になっていると思いますが、この形式からはTGAファイルに変換できません。DDSファイルをTGAファイルに変換するには、TGAファイルに変換可能な形式を選ぶ必要があります。TGAに変換可能な形式は以下の5つです。

>* 32bpp RGBA
>* 32bpp BGRA
>* 32bpp BGR
>* 16bpp BGRA 5551
>* 8bpp Gray

今回は「16bpp BGRA 5551」を選択してください。

プロパティを操作すると、画像ウィンドウのタブ選択が解除されてしまいます。選択が解除されているとメニューの操作対象にできないので、以下のようにタブをクリックして選択状態にしてください。この操作は忘れがちなので注意しましょう。

<p align="center">
<img src="images/08_dds_to_tga_01.png" width="50%" />
</p>

タブを選択したら、ファイルメニューから「名前を付けてPzVI_Tiger_I.ddsを保存」を選択してください。

<p align="center">
<img src="images/08_dds_to_tga_02.png" width="50%" />
</p>

すると「名前を付けてファイルを保存」ウィンドウが開きます。

<p align="center">
<img src="images/08_dds_to_tga_03.png" width="66%" />
</p>

最初は「ファイルの種類」が「Direct Draw Surface(\*.dds)」になっています。この部分をクリックすると、選択可能な種類のリストが表示されますので「TGAファイル(\*.tga)」を選択してください。

ファイルの種類を変更したら「保存」ボタンをクリックします。すると次のようなウィンドウが表示されます。

<p align="center">
<img src="images/08_dds_to_tga_04.png" width="50%" />
</p>

ここで「OK」をクリックすると、画像がTGAファイルとして保存されます。これでTGAへの変換は完了です。

>JPGやPNGファイルの場合も同様の方法でTGAに変換することができます。また、JPGとPNGの場合は形式の選択は不要です。

### 3.3 OBJファイルを表示する

OBJファイルとTGAファイルを手に入れたので表示してみましょう。とりあえず、`Tiger_I.obj`と`PzVI_Tiger_I.tga`をプロジェクトの`Res`フォルダにコピーしてください。

`Main.cpp`を開き、OBJファイルを読み込むプログラムに、次のプログラムを追加してください。

```diff
   primitiveBuffer.AddFromObjFile("Res/Cube.obj");
   primitiveBuffer.AddFromObjFile("Res/Tree.obj");
   primitiveBuffer.AddFromObjFile("Res/Warehouse.obj");
+  primitiveBuffer.AddFromObjFile("Res/Tiger_I.obj");

   // パイプライン・オブジェクトを作成する.
   ProgramPipeline pipeline("Res/VertexLighting.vert", "Res/Simple.frag");
```

次に、テクスチャを読み込むプログラムに、次のプログラムを追加してください。

```diff
   std::shared_ptr<Texture> texRoad(new Texture("Res/Road.tga"));
   std::shared_ptr<Texture> texTree(new Texture("Res/Tree.tga"));
   std::shared_ptr<Texture> texWarehouse(new Texture("Res/Warehouse.tga"));
+  std::shared_ptr<Texture> texTank(new Texture("Res/PzVI_Tiger_I.tga"));

   // サンプラを作成.
   std::shard_ptr<Sampler> sampler(new Sampler(GL_REPEAT));
```

続いて、三角形を描画するプログラムの下に、次のプログラムを追加してください。

```diff
     texTriangle->Bind(0); // テクスチャを割り当てる.
     primitiveBuffer.Get(2).Draw();
     primitiveBuffer.Get(3).Draw();
+
+    // 以下の6という数字は、戦車をprimitiveBufferに追加した順番と一致させること.
+    // この文章の意味が分からない場合は先生に質問してください.
+    // 分かる場合はこのコメントを書く必要はありません.
+    texTank->Bind(0);
+    primitiveBuffer.Get(6).Draw();

     // マップに配置する物体の表示データ.
     struct ObjectData {
```

プログラムが書けたらビルドして実行してください。画面に戦車が表示されていたら成功です。

<p align="center">
<img src="images/08_result_00.png" width="50%" />
</p>

<pre class="tnmai_assignment">
<strong>【課題05】</strong>
インターネットから別のOBJファイルをダウンロードして画面に表示しなさい(戦車以外でも構いません)。
</pre>

### 3.4 戦車の表示位置をずらす

物体が重なっていると見づらいので戦車の表示位置をずらしましょう。戦車を表示するプログラムに、次のプログラムを追加してください。

```diff
     primitiveBuffer.Get(2).Draw();
     primitiveBuffer.Get(3).Draw();

+    {
+      const glm::mat4 matModel =
+        glm::translate(glm::mat4(1), glm::vec3(0, 0, 4));
+      const glm::mat4 matMVP = matProj * matView * matModel;
+      pipeline.SetUniform(locMatTRS, matMVP);
+      pipeline.SetUniform(locMatModel, matModel);
+
       texTank->Bind(0);
       primitiveBuffer.Get(6).Draw();
+    }

     texTank2->Bind(0);
     primitiveBuffer.Get(7).Draw();

     // マップに配置する物体の表示データ.
     struct ObjectData {
```

追加したプログラムは、平行移動行列を作成する`translate`(トランスレート)関数を使って、戦車の位置を動かします。

プログラムが書けたらビルドして実行してください。戦車が下に移動していたら成功です。

<p align="center">
<img src="images/08_result_01.png" width="50%" />
</p>


>**【3章のまとめ】**<br>
>
>* 
>* 

<div style="page-break-after: always"></div>


