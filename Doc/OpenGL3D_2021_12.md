[OpenGL 3D 2021 第12回]

# ゲームの進行を管理する

## 習得目標

* ライブラリの機能をメンバ関数で置き換える手順を理解する。
* 派生クラスでコンストラクタ引数を変更できるようになる。
* 列挙型によってゲームの進行状態を管理できるようになる。
* UI表示のための正投影カメラを作成できるようになる。

## 1. ゲームエンジンでGLFWを管理する

### 1.1 GLFWの初期化をゲームエンジンクラスに移動する

現在のプログラムでは、キー入力やフレームバッファの切り替えなどを行うとき、GLFWライブラリの関数を直接呼び出しています。GLFWライブラリの多くの関数は引数として`GLFWwindow` 型ポインタを受け取ります。

しかし、現在この`GLFWwindow`型ポインタは`main`関数で作成しています。そのため、例えば`Main.cpp`以外のファイルでGLFWライブラリの関数を使いたい場合、このポインタをなんとかしなくてはなりません。

「なんとかする」というのは、具体的には以下の2パターンが考えられます。

>1. ポインタをグローバル変数にして、どのファイルからでも使えるようにする。
>2. ポインタが使えるファイル内に新しい関数を追加し、その関数内でGLFWライブラリの関数を呼び出す。

ところで、プログラミングの歴史における経験則に「グローバル変数はあとあと管理が面倒になることが多い」という経験則があります。つまり、1の「ポインタをグローバル変数にする」はあまり良くない方法といえます。

今回は経験則に従って、2の「新しい関数を追加する」方法を使うことにします。新しい関数を追加する場所は、さまざまなファイルで使うことを想定したファイルやクラスを選びます。

そのようなファイルやクラスがなければ新しく作る必要がありますが、幸いにも現在のプロジェクトには「ゲームエンジンクラス」というぴったりのクラスがあります。

ということで、本章ではGLFWライブラリを使うプログラムをゲームエンジンクラスに移動していきます。まず、ゲームエンジンクラス側に機能を受け入れる準備をします。`GameEngine.h`を開き、次のプログラムを追加してください。

```diff
 #include "Texture.h"
 #include "Actor.h"
+#include <GLFW/glfw3.h>
 #include <unordered_map>
 #include <random>
```

次に`GLFWwindow`型ポインタ変数を追加します。ゲームエンジンクラスの定義に次のプログラムを追加してください。

```diff
   ~GameEngine() = default;
   GameEngine(const GameEngine&) = delete;
   GameEngine& operator=(const GameEngine&) = delete;

+  GLFWwindow* window = nullptr;
   ActorList actors;    // アクター配列
   ActorList newActors; // 追加するアクターの配列
```

これでGLFWライブラリ機能の受け入れ準備は完了です。

### 1.2 OpenGLの初期化をゲームエンジンクラスに移動する

それではGLFWライブラリの機能をゲームエンジンクラスに移していきましょう。最初に、初期化処理をゲームエンジンクラスに移動します。`Main.cpp`を開き、GLFWの初期化からデバッグコールバックの設定までを切り取ってください。

```diff
 * エントリーポイント.
 */
 int main()
 {
-  // GLFWの初期化.
-  if (glfwInit() != GLFW_TRUE) {
-    return 1;
-  }
-
-  // 描画ウィンドウの作成.
-  glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
-  glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GLFW_TRUE);
-  glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4);
-  glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 5);
-  glfwWindowHint(GLFW_OPENGL_DEBUG_CONTEXT, GLFW_TRUE);
-  GLFWwindow* window =
-    glfwCreateWindow(1280, 720, "OpenGLGame", nullptr, nullptr);
-  if (!window) {
-    glfwTerminate();
-    return 1;
-  }
-  glfwMakeContextCurrent(window);
-
-  // OpenGL関数のアドレスを取得する.
-  if (!gladLoadGLLoader(reinterpret_cast<GLADloadproc>(glfwGetProcAddress))) {
-    glfwTerminate();
-    return 1;
-  }
-
-  glDebugMessageCallback(DebugCallback, nullptr);
-  
   GameEngine::Initialize();
   GameEngine& engine = GameEngine::Get();
```

`GameEngine.cpp`を開き、`Initialize`メンバ関数の定義に切り取ったプログラムを貼り付けてください。

```diff
     if (!engine) {
       return false;
     }

+  // GLFWの初期化.
+  if (glfwInit() != GLFW_TRUE) {
+    return 1;
+  }
+
+  // 描画ウィンドウの作成.
+  glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
+  glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GLFW_TRUE);
+  glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4);
+  glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 5);
+  glfwWindowHint(GLFW_OPENGL_DEBUG_CONTEXT, GLFW_TRUE);
+  GLFWwindow* window =
+    glfwCreateWindow(1280, 720, "OpenGLGame", nullptr, nullptr);
+  if (!window) {
+    glfwTerminate();
+    return 1;
+  }
+  glfwMakeContextCurrent(window);
+
+  // OpenGL関数のアドレスを取得する.
+  if (!gladLoadGLLoader(reinterpret_cast<GLADloadproc>(glfwGetProcAddress))) {
+    glfwTerminate();
+    return 1;
+  }
+
+  glDebugMessageCallback(DebugCallback, nullptr);
+
     engine->actors.reserve(1000);
     engine->newActors.reserve(1000);
```

プログラムを貼り付けると「`DebugCallback`が定義されていない」というエラーが発生すると思います。以下の課題を完了してエラーを解決してください。

<pre class="tnmai_assignment">
<strong>【課題01】</strong>
<code>Main.cpp</code>から<code>DebugCallback</code>関数を切り取って、<code>GameEngine.cpp</code>の先頭にある
<code>engine</code>変数の下に貼り付けなさい。<code>std::cerr</code>でエラーが発生する場合は、適切なヘッダファイルをインクルードしてエラーを解消してください。
</pre>

それから、ウィンドウ変数をエンジンの`window`メンバ変数に代入するプログラムを追加します。デバッグコールバックを設定するプログラムの下に、次のプログラムを追加してください。

```diff
       return 1;
     }

     glDebugMessageCallback(DebugCallback, nullptr);
 
+    engine->window = window;
     engine->actors.reserve(1000);
     engine->newActors.reserve(1000);
```

<pre class="tnmai_assignment">
<strong>【課題02】</strong>
貼り付けたプログラムは「失敗」を示す戻り値が</code>1</code>になっていて、イニシャライズ関数の戻り値とは意味が違っています。正しく「失敗」を返すように、貼り付けたプログラムの<code>return 1;</code>を<code>return false;</code>に修正しなさい。
</pre>

### 1.3 GLFWの終了をゲームエンジンクラスに移動する

初期化を移動したので、対になる終了処理もゲームエンジンクラスに移動させます。`Main.cpp`を開き、次のプログラムを切り取ってください。

```diff
     glfwSwapBuffers(window);
   }

   GameEngine::Finalize();

-  // GLFWの終了.
-  glfwTerminate();
-
   return 0;
 }
```

`GameEngine.cpp`を開き、`Finalize`メンバ関数の定義に切り取ったプログラムを貼り付けてください。

```diff
 void GameEngine::Finalize()
 {
+  // GLFWの終了.
+  glfwTerminate();
+
   delete engine;
   engine = nullptr;
```

貼り付けただけだと、誤って`Finalize`メンバ関数が複数回実行してしまうと、`glfwTerminate`関数も複数回実行されてしまいます。これを防ぐため、`engine`変数が有効なときだけ終了処理を行います。`Finalize`メンバ関数を次のように変更してください。

```diff
 void GameEngine::Finalize()
 {
+  if (engine) {
     // GLFWの終了.
     glfwTerminate();

     delete engine;
     engine = nullptr;
+  }
 }
```

### 1.4 GLFW関数をゲームエンジンクラスに実装する

`window`変数を移動させたため、`Main.cpp`で`window`変数を使っている関数は全てエラーになります。これらの関数もゲームエンジンクラスに移動させます。`Main.cpp`を開き、`Ctrl+F`キーを押して検索ウィンドウを表示してください。

次に、検索ウィンドウの検索語句テキストに`window`と入力してください。すると次のように`glfwWindowShouldClose`(ジーエルエフダブリュー・ウィンドウ・シュッド・クローズ)関数を使っている部分が見つかるはずです(見つからない場合は`→`ボタンをクリックして探してください)。

>```c++
>  glm::vec3 cameraPosition = glm::vec3(0, 20, 20); // カメラの座標
>  glm::vec3 cameraTarget   = glm::vec3(0, 0, 0);   // カメラの注視点の座標
>  while (!glfwWindowShouldClose(window)) {
>   // 現在時刻を取得
>```

`glfwWindowShouldClose`関数が見つかったら、検索ウィンドウ内の`☓`ボタンをクリックするか`esc`キーを押して検索ウィンドウを閉じてください。

GLFWライブラリの関数をゲームエンジンクラスに移動させる手順は次のとおりです。

>1. 関数の追加: ゲームエンジンクラスに「GLFWライブラリの関数を呼び出す関数」を追加する。
>2. 関数の置き換え: `Main.cpp`でGLFWライブラリの関数を呼び出している部分を、1で追加した関数に置き換える。

それでは「関数の追加」からやっていきます。`GameEngine.h`を開き、ゲームエンジンクラスに次のプログラムを追加してください。

```diff
   const Primitive& GetPrimitive(int n) const { return primitiveBuffer->Get(n); }

   std::shared_ptr<Texture> LoadTexture(const char* filename);
+
+  /**
+  * この関数がtrueを返したらウィンドウを閉じる(=アプリを終了させる)
+  */
+  bool WindowShouldClose() const
+  {
+    return glfwWindowShouldClose(window);
+  }

 private:
   GameEngine() = default;
```

基本的には、メンバ関数の定義はCPPファイルに書くべきです。しかし、ここで定義している
`WindowSholdClose`(ウィンドウ・シュッド・クローズ)メンバ関数のように、関数の定義が十分に短い（1～3行程度の)場合、直接クラス定義に書いてもよいでしょう。

次に「関数の置き換え」を行います。これは`glfw`を`engine.`に変えて`window`引数をなくすだけです。`Main.cpp`を開き、`glfwWindowShouldClose`関数を使うプログラムを次のように変更してください。

```diff
   glm::vec3 cameraPosition = glm::vec3(0, 20, 20); // カメラの座標
   glm::vec3 cameraTarget   = glm::vec3(0, 0, 0);   // カメラの注視点の座標
-  while (!glfwWindowShouldClose(window)) {
+  while (!engine.WindowShouldClose()) {
    // 現在時刻を取得
```

これで`glfwWindowShouldClose`関数の置き換えは完了です。

### 1.5 glfwGetKey関数をゲームエンジンクラスに移動する

次の置き換え対象を探すために、`Ctrl+F`キーで検索ウィンドウを開き、検索語句テキストに
`window`を入力しましょう。すると`glfwGetKey`(ジーエルエフダブリュー・ゲット・キー)関数が見つかります。

>```c++
>         float tankAccel = 0.2f; // 戦車の加速度
>         if (glfwGetKey(window, GLFW_KEY_W) == GLFW_PRESS) {
>           tank->velocity += tankFront * tankAccel;
>         } else if (glfwGetKey(window, GLFW_KEY_S) == GLFW_PRESS) {
>           tank->position -= tankFront * tankAccel;
>         }
>```

それでは「関数の追加」を行いましょう。`GameEngine.h`を開き、ゲームエンジンクラスに次のプログラムを追加してください。

```diff
   bool WindowShouldClose() const
   {
     return glfwWindowShouldClose(window);
   }
+
+  /**
+  * キーが押されていたらtrue、押されていなかったらfalse
+  */
+  bool GetKey(int key) const
+  {
+    return glfwGetKey(window, key) == GLFW_PRESS;
+  }

 private:
   GameEngine() = default;
```

次に、追加した関数で`glfwGetKey`関数を置き換えます。`Main.cpp`を開き、`glfwGetKey`
を使っているプログラムを次のように変更してください。

```diff
         float tankAccel = 0.2f; // 戦車の加速度
-        if (glfwGetKey(window, GLFW_KEY_W) == GLFW_PRESS) {
+        if (engine.GetKey(GLFW_KEY_W)) {
           tank->velocity += tankFront * tankAccel;
-        } else if (glfwGetKey(window, GLFW_KEY_S) == GLFW_PRESS) {
+        } else if (engine.GetKey(GLFW_KEY_S)) {
           tank->position -= tankFront * tankAccel;
         }
```

<pre class="tnmai_assignment">
<strong>【課題03】</strong>
<code>Main.cpp</code>にある全ての<code>glfwGetKey</code>関数呼び出しを、ゲームエンジンクラスの<code>GetKey</code>メンバ関数で置き換えなさい。
</pre>

<pre class="tnmai_assignment">
<strong>【課題04】</strong>
<code>glfwWindowShouldClose</code>関数と<code>glfwGetKey</code>関数の置き換えかたを参考に、
<code>glfwGetMouseButton</code>関数呼び出しをゲームエンジンクラスのメンバ関数で置き換えなさい。メンバ関数名は<code>GetMouseButton</code>としなさい。
</pre>

### 1.6 glfwGetWindowSize関数をゲームエンジンクラスに移動する

`Ctrl+F`を押して検索語句`window`の検索を続けます。すると`glfwGetWindowSize`関数が見つかるでしょう。

>```c++
>    // プロジェクション行列を作成.
>    int w, h;
>    glfwGetWindowSize(window, &w, &h);
>    const float aspectRatio = static_cast<float>(w) / static_cast<float>(h);
>    const glm::mat4 matProj =
>      glm::perspective(glm::radians(45.0f),  aspectRatio, 0.1f, 200.0f);
>```

`glfwGetWindowSize`関数は、引数で受け取ったアドレスに値を代入するタイプの関数です。昔のC言語では構造体を戻り値にできなかったため、このような設計をするのが普通でした。

しかし、現代のCは関数の戻り値に構造体を指定できますし、C++は最初から構造体やクラスを返すことができるように作られています。そこで、ゲームエンジンクラスに追加するメンバ関数は、`glm::vec2`型の値を返すように設計します。

また、ウィンドウサイズはあまり<ruby>頻繁<rt>ひんぱん</rt></ruby>に変更されないと考えられます。ゲームエンジンの初期化時にサイズを取得し、サイズ変更を検知したときに更新すれば十分でしょう。

ウィンドウサイズを格納するメンバ変数を用意します。`GameEngine.h`を開き、ゲームエンジンクラスの定義に次のプログラムを追加してください。

```diff
   GameEngine& operator=(const GameEngine&) = delete;

   GLFWwindow* window = nullptr;
+  glm::vec2 windowSize = glm::vec2(0);
   ActorList actors;    // アクター配列
   ActorList newActors; // 追加するアクターの配列
```

次に、ウィンドウサイズを返すメンバ関数を追加します。ゲームエンジンクラスの定義に次のプログラムを追加してください。

```diff
   {
     return glfwGetMouseButton(window, button);
   }
+
+  /**
+  * ウィンドウサイズを返す
+  */
+  glm::vec2 GetWindowSize() const
+  {
+    return windowSize;
+  }

 private:
   GameEngine() = default;
```

続いて、ゲームエンジンの初期化時にウィンドウサイズを取得します。`GameEngine.cpp`を開き、`Initialize`メンバ関数の定義に次のプログラムを追加してください。

```diff
     glDebugMessageCallback(DebugCallback, nullptr);

     engine->window = window;
+    int w, h;
+    glfwGetWindowSize(window, &w, &h);
+    engine->windowSize = glm::vec2(w, h);
+
     engine->actors.reserve(1000);
     engine->newActors.reserve(1000);
```

最後に、`Main.cpp`の`glfwGetWindowSize`関数を次のように置き換えてください。

```diff
     // プロジェクション行列を作成.
-    int w, h;
-    glfwGetWindowSize(window, &w, &h);
-    const float aspectRatio = static_cast<float>(w) / static_cast<float>(h);
+    const glm::vec2 windowSize = engine.GetWindowSize();
+    const float aspectRatio = windowSize.x / windowSize.y;
     const glm::mat4 matProj =
       glm::perspective(glm::radians(45.0f),  aspectRatio, 0.1f, 200.0f);
```

C言語を想定したライブラリの場合、C++で使いやすい形の関数に置き換えると、ほんの少しですがプログラムを管理しやすくなります。

### 1.7 glfwSwapBuffers関数をゲームエンジンクラスに移動する

`window`変数の検索を続けると、`glfwSwapBuffers`(ジーエルエフダブリュー・スワップ・バッファーズ)関数が見つかるでしょう。この関数もゲームエンジンクラスに移動します。

>```c++
>    pipeline.Unbind();
>    primitiveBuffer.UnbindVertexArray();
>
>    glfwPollEvents();
>    glfwSwapBuffers(window);
>  }
>
>  // ゲームエンジンを終了する
>  GameEngine::Finalize();
>```

そばにある`glfwPollEvents`(ジーエルエフダブリュー・ポール・イベンツ)関数もGLFWライブラリの関数です。これも一緒に移動させましょう。まずはメンバ関数を追加します。
`GameEngine.h`を開き、ゲームエンジンクラスの定義に次のプログラムを追加してください。

```diff
   {
     return windowSize;
   }
+
+  /**
+  * フロントバッファとバックバッファを交換する
+  */
+  void SwapBuffers() const
+  {
+    glfwSwapBuffers(window);
+    glfwPollEvents();
+  }
  
 private:
   GameEngine() = default;
```

次に`Main.cpp`を開き、`glfwSwapBuffers`と`glfwPollEvents`関数を以下のように置き換えてください。

```diff
     pipeline.Unbind();
     primitiveBuffer.UnbindVertexArray();

-    glfwPollEvents();
-    glfwSwapBuffers(window);
+    engine.SwapBuffers();
   }

   // ゲームエンジンを終了する
   GameEngine::Finalize();
```

ここまでの変更によって、GLFWライブラリの機能をゲームエンジンクラス経由で使えるようになりました。今後はどのCPPファイルからでもGLFWライブラリの機能を利用できます。

<pre class="tnmai_assignment">
<strong>【課題05】</strong>
<code>Main.cpp</code>にある全ての<code>glfwGetTime</code>関数呼び出しを、ゲームエンジンクラスのメンバ関数で置き換えなさい。メンバ関数名は<code>GetTime</code>としなさい。
</pre>

<pre class="tnmai_assignment">
<strong>【課題06】</strong>
もしテキストで扱っていないGLFWライブラリの関数を使っている場合、それらの関数をゲームエンジンクラスのメンバ関数で置き換えなさい。
他のGLFWライブラリの関数を使っていない場合は、この課題を無視してください。
</pre>

<pre class="tnmai_assignment">
<strong>【課題07】</strong>
現在使用している全てのGLFWライブラリの関数を、ゲームエンジンクラスのメンバ関数で置き換えなさい。置き換えが終わったら、<code>Main.cpp</code>から<code>GLFW/glfw3.h</code>のインクルード文を削除しなさい。
</pre>

### 1.8 プリミティブに名前を付ける

読み込むプリミティブの数が増えてくると、プリミティブを番号で識別することが難しくなっていきます。そこで、プリミティブに名前を付けて、名前で検索できるようにします。
`Primitive.h`を開き、プリミティブクラスを次のように変更してください。

```diff
 class Primitive
 {
 public:
   Primitive() = default;
-  Primitive(GLenum m, GLsizei c, size_t o, GLint b) :
+  Primitive(const char* name, GLenum m, GLsizei c, size_t o, GLint b) :
+    name(name),
     mode(m), count(c), indices(reinterpret_cast<GLvoid*>(o)), baseVertex(b)
   {}
   ~Primitive() = default;
 
   void Draw() const;
+  const std::string& GetName() const { return name; }
 
 private:
+  std::string name;           // プリミティブ名
   GLenum mode = GL_TRIANGLES; // プリミティブの種類.
   GLsizei count = 0; // 描画するインデックス数.
```

次に、プリミティブバッファクラスのアド関数に、名前を受け取る引数を追加します。アド関数の宣言を次のように変更してください。

```diff
   // プリミティブの追加
   bool Add(size_t vertexCount, const glm::vec3* pPosition, const glm::vec4* pColor,
     const glm::vec2* pTexcoord, const glm::vec3* pNormal,
-    size_t indexCount, const GLushort* pIndex);
+    size_t indexCount, const GLushort* pIndex, const char* name = nullptr);
   bool AddFromObjFile(const char* filename);

   // プリミティブの取得
```

それでは、アド関数を修正しましょう。`Primitive.cpp`を開き、アド関数を次のように変更してください。

```diff
 * @param indexCount  追加するインデックスデータの数
 * @param pIndex      インデックスデータへのポインタ
+* @param name        プリミティブの名前
 *
 * @retval true  追加に成功
 * @retval false 追加に失敗
 */
 bool PrimitiveBuffer::Add(size_t vertexCount, const glm::vec3* pPosition,
   const glm::vec4* pColor, const glm::vec2* pTexcoord, const glm::vec3* pNormal,
-  size_t indexCount, const GLushort* pIndex)
+  size_t indexCount, const GLushort* pIndex, const char* name)
 {
   // エラーチェック.
```

さらに、アド関数の描画データを作成するプログラムを次のように変更してください。

```diff
   if (!CopyData(ibo, sizeof(GLushort), curIndexCount, indexCount, pIndex)) {
     return false;
   }

   // 描画データを作成.
-  const Primitive prim(GL_TRIANGLES, static_cast<GLsizei>(indexCount),
+  const Primitive prim(name, GL_TRIANGLES, static_cast<GLsizei>(indexCount),
     sizeof(GLushort) * curIndexCount, curVertexCount);

   // 描画データを配列に追加.
```

それから、アドフロムオブジェ関数の場合は「ファイル名を名前として使う」ことにしましょう。というのは、ファイル名とは異なるプリミティブ名を覚えるのは面倒だからです。アドフロムオブジェ関数を次のように変更してください。

```diff
   // 頂点データとインデックスデータをGPUメモリにコピーする.
   const bool result = Add(positions.size(), positions.data(), colors.data(),
-    texcoords.data(), normals.data(), indices.size(), indices.data());
+    texcoords.data(), normals.data(), indices.size(), indices.data(),
+    filename);
   if (result) {
    std::cout << "[情報]" << __func__ << ":" << filename << "(頂点数=" <<
```

これで、プリミティブに名前を設定できるようになりました。

### 1.9 プリミティブを名前で検索する

次に、プリミティブバッファクラスに「名前による検索」機能を追加します。メンバ関数名は
`Find`(ファインド。「探す」、「見つける」という意味)とします。`Primitive.h`を開き、プリミティブバッファクラスの定義に次のプログラムを追加してください。

```diff
   bool AddFromObjFile(const char* filename);

   // プリミティブの取得
   const Primitive& Get(size_t n) const;
+  const Primitive& Find(const char* name) const;

   // VAOバインド管理.
   void BindVertexArray() const;
```

続いてファインド関数を定義します。`Primitive.cpp`を開き、`Get`メンバ関数の定義の下に、次のプログラムを追加してください。

```diff
     return dummy;
   }
   return primitives[n];
 }
+
+/**
+* プリミティブを取得する
+*
+* @param name プリミティブの名前
+*
+* @return 名前がnameと一致するプリミティブ
+*/
+const Primitive& PrimitiveBuffer::Find(const char* name) const
+{
+  for (int i = 0; i < primitives.size(); ++i) {
+    if (primitives[i].GetName() == name) {
+      // 名前が一致する描画データを見つけた(見つけた描画データを返す)
+      return primitives[i];
+    }
+  }
+
+  // 名前が一致する描画データは見つからなかった(仮の描画データを返す)
+  static const Primitive dummy;
+  return dummy;
+}

 /**
 * VAOをグラフィックスパイプラインにバインドする
```

作成したファインド関数と、前節で行ったアドフロムオブジェ関数の変更の2つが組み合わさることで、ファイル名を使ってプリミティブを検索できるようになりました。

### 1.10 ゲームエンジンクラスにプリミティブ検索機能を追加する

プリミティブを検索するには、ゲームエンジンクラスからプリミティブバッファクラスを取得し、プリミティブバッファクラスのファインド関数を使う、という手順が必要です。

これはちょっと面倒なので、ゲームエンジンクラスにプリミティブを検索する機能を追加しましょう。`GameEngine.h`を開き、ゲームエンジンクラスの定義に次のプログラムを追加してください。

```diff
   PrimitiveBuffer& GetPrimitiveBuffer() { return *primitiveBuffer; }
   const Primitive& GetPrimitive(int n) { return primitiveBuffer->Get(n); }
+  const Primitive& GetPrimitive(const char* name) const;

   std::shared_ptr<Texture> LoadTexture(const char* filename);

   /**
   * この関数がtrueを返したらウィンドウを閉じる(=アプリを終了させる)
```

次に`GameEngine.cpp`を開き、アップデートアクターズ関数の定義の下に、次のプログラムを追加してください。

```diff
   // 新規アクター配列を空にする
   newActors.clear();
 }
+
+/**
+* 名前の一致するプリミティブを取得する
+*
+* @param filename プリミティブ名
+*
+* @return filenameと名前が一致するプリミティブ
+*/
+const Primitive& GameEngine::GetPrimitive(const char* filename) const
+{
+  return primitiveBuffer->Find(filename);
+}

 /**
 * テクスチャを読み込む
```

これで、ゲームエンジンクラスから直接プリミティブを取得できます。

>**【1章のまとめ】**<br>
>
>* ライブラリの機能をクラスのメンバ関数で置き換えると、ライブラリを直接使う場合より管理しやすくなる。
>* オブジェクトを名前で検索する機能があると便利。

<div style="page-break-after: always"></div>

## 2. タイガーI戦車をクラスにする

### 2.1 タイガーI戦車用のクラスを定義する

本章では、タイガーI戦車のプログラムを`Main.cpp`から別のファイルに分離します。以前のタイガーI戦車を操作するプログラムは`window`変数を必要とするGLFWライブラリの関数を使っていたため、別のファイルに分離することが簡単ではありませんでした。

現在、それらの関数は全てゲームエンジンクラスのメンバ関数で置き換え済みです。この置き換えにより、タイガーI戦車を操作するプログラムを別のファイルに分離できるようになりました。

プロジェクトの`Src\Actor`フォルダに`PlayerActor.h`というヘッダファイルを追加してください。追加したファイルを開き、次のプログラムを追加してください。アクタークラスをコピーして、名前などを変更すると早くできるでしょう。

```diff
+/**
+* @file PlayerActor.h
+*/
+#ifndef PLAYERACTOR_H_INCLUDED
+#define PLAYERACTOR_H_INCLUDED
+#include "../Actor.h"
+
+/**
+* プレイヤーが操作する戦車
+*/
+class PlayerActor : public Actor
+{
+public:
+  PlayerActor(
+    const std::string& name,
+    const Primitive& prim,
+    std::shared_ptr<Texture> tex,
+    const glm::vec3& position,
+    const glm::vec3& scale,
+    float rotation,
+    const glm::vec3& adjustment);
+
+  virtual ~PlayerActor() = default;
+  virtual void OnUpdate(float deltaTime);
+  virtual void OnCollision(const struct Contact& contact);
+
+private:
+};
+
+#endif // PLAYERACTOR_H_INCLUDED
```

それにしても、コンストラクタの引数が多いのはなんとかならないものでしょうか…。

改めて引数の必要性を考えてみると、例えばタイガーI戦車の「名前」は`Tiger-I`に決まっています。「プリミティブ」は`Tiger_I.obj`で「テクスチャ」は`PzVl_Tiger_I.tga`
を使うはずです。

つまり、これらのパラメータを自由に変更できる必要はありません。コンストラクタの中で決まった値を指定すれば十分だと考えられます。ということは、これらの引数をコンストラクタから削除しても大丈夫そうです。

さっそく不要な引数を削除しましょう。コンストラクタの宣言を次のように変更してください。

```diff
 public:
   PlayerActor(
-    const std::string& name,
-    const Primitive& prim,
-    std::shared_ptr<Texture> tex,
     const glm::vec3& position,
     const glm::vec3& scale,
-    float rotation,
+    float rotation);
-    const glm::vec3& adjustment);

   virtual ~PlayerActor() = default;
   virtual void OnUpdate(float deltaTime);
```

次に、タイガーI戦車の操作に必要な変数をプライベートメンバに追加します。`Main.cpp`をざっとながめたところ、`oldShotButton`変数が必要なようです。

>```c++
>   double loopTime = glfwGetTime();     // 1/60秒間隔でループ処理するための時刻
>   double diffLoopTime = 0;             // 時刻の差分
>   const float deltaTime = 1.0f / 60.0f;// 更新間隔
>   int    oldShotButton = 0;        // 前回のショットボタンの状態
>   while (!glfwWindowShouldClose(window)) {
>     // 現在時刻を取得
>```

`oldShotButton`変数を定義している行をコピーして、次のように`PlayerActor.h`に貼り付けてください。

```diff
   virtual void OnUpdate(float deltaTime);
   virtual void OnCollision(const struct Contact& contact);

 private:
+  int oldShotButton = 0;               // 前回のショットボタンの状態
 };

 #endif // PLAYERACTOR_H_INCLUDED
```

### 2.2 コンストラクタを定義する

それではコンストラクタから定義していきましょう。プロジェクトの`Src\Actor`フォルダに`PlayerActor.cpp`というヘッダファイルを追加してください。追加したファイルを開き、次のプログラムを追加してください。

```diff
+/**
+* @file PlayerActor.cpp
+*/
+#include "PlayerActor.h"
+#include "../GameEngine.h"
+
+/**
+* コンストラクタ
+*/
+PlayerActor::PlayerActor(
+  const glm::vec3& position,
+  const glm::vec3& scale,
+  float rotation) :
+  Actor(
+    "Tiger-I",
+    GameEngine::Get().GetPrimitive("Res/Tiger_I.obj"),
+    GameEngine::Get().LoadTexture("Res/PzVl_Tiger_I.tga"),
+    position, scale, rotation, glm::vec3(0))
+{
+}
```

また、タイガーI戦車のコライダーを`Main.cpp`で設定していますが、これも決まった値を設定するだけなので、コンストラクタに移動できます。`Main.cpp`を開き、タイガーI戦車にコライダーを設定するプログラムを切り取ってください。

```diff
   // 戦車のパラメータ
   std::shared_ptr<Actor> playerTank(new Actor{ "Tiger-I", primitiveBuffer.Get(6),
     texTank, glm::vec3(0), glm::vec3(1), 0.0f, glm::vec3(0) });
-  playerTank->collider = Box{ glm::vec3(-1.8f, 0, -1.8f), glm::vec3(1.8f, 2.8f, 1.8f) };
   actors.push_back(playerTank);
```

`PlayerActor.cpp`に戻り、切り取ったプログラムをコンストラクタに貼り付けてください。

```diff
     GameEngine::Get().LoadTexture("Res/PzVl_Tiger_I.tga"),
     position, scale, rotation, glm::vec3(0))
 {
+  playerTank->collider = Box{ glm::vec3(-1.8f, 0, -1.8f), glm::vec3(1.8f, 2.8f, 1.8f) };
 }
```

それから、`playerTank->`の部分は不要なので削除します。コライダーを設定するプログラムを次のように変更してください。

```diff
     GameEngine::Get().LoadTexture("Res/PzVl_Tiger_I.tga"),
     position, scale, rotation, glm::vec3(0))
 {
-  playerTank->collider = Box{ glm::vec3(-1.8f, 0, -1.8f), glm::vec3(1.8f, 2.8f, 1.8f) };
+  collider = Box{ glm::vec3(-1.8f, 0, -1.8f), glm::vec3(1.8f, 2.8f, 1.8f) };
 }
```

これでコンストラクタは完成です。

>**【あなたのゲームにscaleやrotationは必要ですか？】**<br>
>もし「自分が作りたいゲームでは特に使わないな」と思う引数がまだあるなら、それらも削除して構いません。

### 2.3 <ruby>OnUpdate<rt>オン・アップデート</rt></ruby>仮想関数を定義する

コンストラクタの次はオンアップデート仮想関数を定義します。オンアップデート仮想関数は「アクターの位置などを更新するための関数」です。コンストラクタの定義の下に、次のプログラムを追加してください。

```diff
     position, scale, rotation, glm::vec3(0))
 {
 }
+
+/**
+* アクターの状態を更新する
+*
+* @param deltaTime 前回の更新からの経過時間(秒)
+*/
+void PlayerActor::OnUpdate(float deltaTime)
+{
+  GameEngine& engine = GameEngine::Get();
+}
```

オンアップデート仮想関数でやるべきことは、アクターの位置や速度の更新です。タイガーI戦車については、`Main.cpp`にある「タイガーI戦車を移動させるプログラム」が該当します。

このプログラムをオンアップデート関数に移動すれば、タイガーI戦車の移動をオンアップデート関数で管理できるようになるはずです。`Main.cpp`を開き、タイガーI戦車を移動させるプログラムを切り取ってください。

```diff
     // ゲーム状態を更新する
     //

     for (; diffLoopTime >= deltaTime; diffLoopTime -= deltaTime) {
-
-     // 戦車を移動させる
-     Actor* tank = Find(actors, "Tiger-I");
-     if (tank) {
-       if (engine.GetKey(GLFW_KEY_A)) {
-         tank->rotation += glm::radians(90.0f) * deltaTime;
-                 ・
-                 ・
-                 ・
-         // 弾に衝突判定を付ける
-         bullet->collider = Box{ glm::vec3(-0.25f), glm::vec3(0.25f) };
-         bullet->mass = 6.8f;
-         bullet->friction = 1.0f;
-
-         actors.push_back(bullet);
-       }
-
-       // 「前回のショットボタンの状態」を更新する
-       oldShotButton = shotButton;
-     }

      // アクターの状態を更新する
      for (int i = 0; i < actors.size(); ++i) {
```

次に`PlayerActor.cpp`を開き、オンアップデート関数に切り取ったプログラムを貼り付けてください。

```diff
 void PlayerActor::OnUpdate(float deltaTime)
 {
   GameEngine& engine = GameEngine::Get();
+
+     // 戦車を移動させる
+     Actor* tank = Find(actors, "Tiger-I");
+     if (tank) {
+       if (engine.GetKey(GLFW_KEY_A)) {
+         tank->rotation += glm::radians(90.0f) * deltaTime;
+                 ・
+                 ・
+                 ・
+         // 弾に衝突判定を付ける
+         bullet->collider = Box{ glm::vec3(-0.25f), glm::vec3(0.25f) };
+         bullet->mass = 6.8f;
+         bullet->friction = 1.0f;
+
+         actors.push_back(bullet);
+       }
+
+       // 「前回のショットボタンの状態」を更新する
+       oldShotButton = shotButton;
+     }
 }
```

先頭の`Fnid`関数とそれに続く`if`は不要なので削除します。

```diff
   GameEngine& engine = GameEngine::Get();

      // 戦車を移動させる
-     Actor* tank = Find(actors, "Tiger-I");
-     if (tank) {
        if (engine.GetKey(GLFW_KEY_A)) {
          tank->rotation += glm::radians(90.0f) * deltaTime;
                  ・
                  ・
                  ・
          // 弾に衝突判定を付ける
          bullet->collider = Box{ glm::vec3(-0.25f), glm::vec3(0.25f) };
          bullet->mass = 6.8f;
          bullet->friction = 1.0f;
 
          actors.push_back(bullet);
        }
 
        // 「前回のショットボタンの状態」を更新する
        oldShotButton = shotButton;
-     }
 }
```

ここでVisual Studio上部のメニューから「編集→詳細→ドキュメントのフォーマット」を選択して空白の数を整理しておいてください。

<pre class="tnmai_assignment">
<strong>【課題08】</strong>
テキスト第11回 2章のT-34戦車のオンアップデート関数を定義する手順を参考にして、オンアップデート関数内の全ての<code>tank-></code>を削除しなさい。
なお、変数名が重複するため、<code>tank->position</code>の部分は<code>this->position</code>のように<code>tank-></code>を<code>this-></code>で置き換える必要があります。
</pre>

<pre class="tnmai_assignment">
<strong>【課題09】</strong>
<code>`rotate`: `glm`のメンバではありません</code>のように「～のメンバではありません」のようなエラーが出た場合、エラーメッセージに書かれた関数宣言を含むヘッダファイルをインクルードすれば直ります。
例えば、<code>rotate</code>関数は<code>glm/gtc/matrix_transform.hpp</code>ヘッダに定義されています。
<code>GameEngine.cpp</code>に<code>rotate</code>関数が定義されているヘッダをインクルードしてエラーを解決しなさい。
</pre>

### 2.4 ゲームエンジンクラスを使ってエラーを解決する

次にプリミティブとテクスチャの取得を修正します。`bullet`変数を定義するプログラムを次のように変更してください。

```diff
     glm::vec3 position = position + tankFront * 6.0f;
     position.y += 2.0f;

     std::shared_ptr<Actor> bullet(new Actor{
-      "Bullet", primitiveBuffer.Get(9), texBullet,
+      "Bullet",
+      engine.GetPrimitive("Res/Bullet.obj"),
+      engine.LoadTexture("Res/Bullet.tga"),
       position, glm::vec3(0.25f), rotation, glm::vec3(0) });

     // 1.5秒後に弾を消す
     bullet->lifespan = 1.5f;
```

続いて、弾アクターをアクター配列に追加するプログラムを次のように変更してください。

```diff
     // 弾に衝突判定を付ける
     bullet->collider = Box{ glm::vec3(-0.25f), glm::vec3(0.25f) };

-    actors.push_back(bullet);
+    engine.AddActor(bullet);
   }

   // 「前回のショットボタンの状態」を更新する
   oldShotButton = shotButton;
```

### 2.5 <ruby>OnCollision<rt>オン・コリジョン</rt></ruby>仮想関数を定義する

次にオンコリジョン仮想関数を定義します。オンコリジョン仮想関数は衝突の結果を扱う関数です。関数の内容は、

>1. T-34戦車が発射する弾に衝突したら、ヘルス(`health`)を減らす。
>2. ヘルスが`0`以下になったら削除する。
>3. エネミーバレットアクターを削除する。

とします。オンアップデート仮想関数の定義の下に、次のプログラムを追加してください。

```diff
   // 「前回のショットボタンの状態」を更新する
   oldShotButton = shotButton;
 }
+
+/**
+* 衝突を処理する
+*
+* @param contact 衝突情報
+*/
+void PlayerActor::OnCollision(const struct Contact& contact)
+{
+  if (contact.b->name == "EnemyBullet") {
+    --health;
+    if (health <= 0) {
+      isDead = true;
+    }
+    contact.b->isDead = true;
+  }
+}
```

また、アクターのデフォルトのヘルスは`1`しかありません。これではすぐに死んでしまうので、ヘルスを`10`に増やしましょう。コンストラクタに次のプログラムを追加してください。

```diff
     GameEngine::Get().LoadTexture("Res/PzVl_Tiger_I.tga"),
     position, scale, rotation, glm::vec3(0))
 {
+  health = 10;
   collider = Box{ glm::vec3(-1.8f, 0, -1.8f), glm::vec3(1.8f, 2.8f, 1.8f) };
 }

 /**
 * アクターの状態を更新する
```

### 2.6 PlayerActorクラスを使う

作成したプレイヤーアクターで既存のプログラムを置き換えましょう。`Main.cpp`を開き、次のインクルード文を追加します。

```diff
 #include "Texture.h"
 #include "Sampler.h"
 #include "Actor.h"
+#include "Actor/PlayerActor.h"
 #include "Actor/T34TankActor.h"
 #include "Actor/ElevatorActor.h"
```

次に、戦車のパラメータを設定するプログラムを次のように変更してください。

```diff
   actors.push_back(std::shared_ptr<Actor>(new Actor{ "Cube", primitiveBuffer.Get(3), texTriangle,
     glm::vec3(0, 0, -4), glm::vec3(1), 0.0f, glm::vec3(0) }));

   // 戦車のパラメータ
-  std::shared_ptr<Actor> playerTank(new Actor{ "Tiger-I", primitiveBuffer.Get(6),
-    texTank, glm::vec3(0), glm::vec3(1), 0.0f, glm::vec3(0) });
+  std::shared_ptr<Actor> playerTank(new PlayerActor{ glm::vec3(0), glm::vec3(1), 0.0f});
   actors.push_back(playerTank);

   // T-34戦車のパラメータ
```

プログラムが書けたらビルドして実行してください。普通にタイガーI戦車を操縦できていたら成功です。敵の弾を10発受けたらタイガーI戦車が消えることも確認してください。

>**【2章のまとめ】**<br>
>
>* コンストラクタの引数は基底クラスと違っていてもよい。
>* プログラムをメンバ関数に変換するとき、どの変数がメンバ変数で置き換えられるかについて、常に注意を払う必要がある。

<div style="page-break-after: always"></div>

## 3. ゲームのルールを管理する

### 3.1 ゲームルール管理クラスを作成する

ゲームにはルールが必要です。ここでいう「ルール」とは、「敵を全滅させたら勝ち」のようなゲーム内容に関わるものだけでなく、ゲームの開始方法や終了方法など、ゲームの進行に関わるすべての条件を指します。

大抵のゲームには、ゲームのルールを管理するための専用のクラスがあります。また、ゲームの規模がある程度大きい場合などは、ルールが複数のクラスに分割されていることが多いです。

この章では、ルール管理を行うクラスをひとつだけ作成します。クラス名は`GameManager`
(ゲーム・マネージャ)とします。プロジェクトの`Src`フォルダに`GameManager.h`(ゲームマネージャ・エイチ)というファイルを作成してください。

作成したファイルを開き、次のプログラムを追加してください。

```diff
+/**
+* @file GameManager.h
+*/
+#ifndef GAMEMANAGER_H_INCLUDED
+#define GAMEMANAGER_H_INCLUDED
+#include "Actor.h"
+#include <vector>
+
+/**
+* ゲーム管理クラス
+*/
+class GameManager
+{
+public:
+  static bool Initialize();
+  static void Finalize();
+  static GameManager& Get();
+
+private:
+  GameManager() = default;
+  ~GameManager() = default;
+  GameManager(const GameManager&) = delete;
+  GameManager& operator=(const GameManager&) = delete;
+};
+
+#endif // GAMEMANAGER_H_INCLUDED
```

ゲームマネージャの定義は「シングルトン」にしています。ゲームルールを管理するシステムはひとつあれば十分だからです。

### 3.2 シングルトンのためのメンバ関数を定義する

ゲームマネージャのメンバ関数を定義していきます。まずプロジェクトの`Src`フォルダに
`GameManager.cpp`(ゲームマネージャ・シーピーピー)というファイルを追加してください。追加したファイルを開き、次のプログラムを追加してください。

```diff
+/**
+* @file GameManager.cpp
+*/
+#include "GameManager.h"
+#include "GameEngine.h"
+#include "Actor/PlayerActor.h"
+#include "Actor/T34TankActor.h"
+#include <iostream>
+
+namespace {
+
+GameManager* manager = nullptr;
+
+}
+
+/**
+* ゲームマネージャの初期化
+*/
+bool GameManager::Initialize()
+{
+  if (!manager) {
+    manager = new GameManager;
+  }
+  return true;
+}
+
+/**
+* ゲームマネージャの終了
+*/
+void GameManager::Finalize()
+{
+  if (manager) {
+    delete manager;
+    manager = nullptr;
+  }
+}
+
+/**
+* ゲームエンジンを取得する
+*/
+GameManager& GameManager::Get()
+{
+  return *manager;
+}
```

シングルトンの基本的な構造は、第11回で作成したゲームエンジンクラスと同じです。コンストラクタ、コピー代入演算子などをプライベート定義して勝手に作れないようにし、イニシャライズ関数とファイナライズ関数でオブジェクトの作成を制御します。

### 3.3 ゲームの動作状態を考える

続いて、ゲームの骨格となる「ゲームの動作状態」を定義します。大抵のゲームには「ゲームの開始」、「ゲームをプレイ中」、「会話」、「ステータス表示」、「ゲームクリア」のように、いくつかの異なる動作状態が存在します。

動作状態の数や種類は個々のゲームによって違います。本テキストで作成するゲームでは、次の4つの動作状態を定義することにします。

>1. ゲーム開始
>2. ゲームプレイ中
>3. ゲームクリア
>4. ゲームオーバー

これらを列挙型として定義します。列挙型の名前は`State`(ステート、「状態」という意味)としましょう。`GameManager.h`を開き、次のプログラムを追加してください。

```diff
   static void Finalize();
   static GameManager& Get();
+
+  // ゲームの動作状態
+  enum class State {
+    start,     // ゲーム開始
+    playing,   // ゲームプレイ中
+    gameclear, // ゲームクリア
+    gameover,  // ゲームオーバー
+  };
 
 private:
   GameManager() = default;
```

次に動作状態を保持するメンバ変数を追加します。ゲームマネージャクラスに次のプログラムを追加してください。

```diff
   GameManager(const GameManager&) = delete;
   GameManager& operator=(const GameManager&) = delete;
+
+  State state = State::start; // 現在の動作状態
 };

 #endif // GAMEMANAGER_H_INCLUDED
```

`state`(ステート)メンバ変数は、ゲームの進行に応じて適切な値に変更する必要があります。

### 3.4 動作状態を更新するメンバ関数を定義する

次に、動作状態の更新を行うメンバ関数を追加します。ゲームの動作状態の更新は、タイガーI戦車や敵となるT-34戦車の状態を監視することで行います。例えば、全てのT-34戦車が破壊されていたら動作状態を`gameclear`にする、タイガーI戦車が破壊されていたら`gameover`にする、などです。

関数名は`Update`(アップデート)とします。`GameManager.h`を開き、次のプログラムを追加してください。

```diff
     gameclear, // ゲームクリア
     gameover,  // ゲームオーバー
   };
+
+  void Update(float deltaTime);
 
 private:
   GameManager() = default;
```

`GameManager.cpp`を開き、ゲット関数の定義の下に次のプログラムを追加してください。

```diff
 {
   return *manager;
 }
+
+/**
+* ゲームの動作状態を更新する
+*/
+void GameManager::Update(float deltaTime)
+{
+  GameEngine& engine = GameEngine::Get();
+
+  switch (state) {
+  case State::start:
+    state = State::playing;
+    std::cout << __func__ << ": start -> playing\n";
+    break;
+
+  case State::playing:
+    if (/*タイガーI戦車が死んでいる？*/) {
+      state = State::gameover;
+      std::cout << __func__ << ": playing -> gameover\n";
+    }
+    else {
+      if (/*T-34戦車が全滅している？*/) {
+        state = State::gameclear;
+        std::cout << __func__ << ": playing -> gameclear\n";
+      }
+    }
+    break;
+
+  case State::gameclear:
+    if (engine.GetKey(GLFW_KEY_ENTER)) {
+      state = State::start;
+      std::cout << __func__ << ": gameclear -> start\n";
+    }
+    break;
+
+  case State::gameover:
+    if (engine.GetKey(GLFW_KEY_ENTER)) {
+      state = State::start;
+      std::cout << __func__ << ": gameover -> start\n";
+    }
+    break;
+  }
+}
```

上記のプログラムでは「タイガーI戦車が死んでいる？」、「T-34戦車が全滅している？」の部分がコメントになっていて、このままではビルドできません。

この2つのコメントをプログラムするには、ゲームマネージャがタイガーI戦車とT-34戦車の状態を調べられるようにする必要があります。

### 3.5 ゲームマネージャでタイガーI戦車を作成する

タイガーI戦車やT-34戦車の状態を調べるには、ゲームマネージャクラスがそれらの戦車アクターを知っていなくてはなりません。まずはアクターを監視するためのメンバ変数を追加します。
`GameManager.h`を開き、次のプログラムを追加してください。

```diff
   GameManager& operator=(const GameManager&) = delete;

   State state = State::start; // 現在の動作状態
+  std::shared_ptr<Actor> playerTank;
+  std::vector<std::shared_ptr<Actor>> enemies;
 };
```

ゲームを何度も繰り返し遊べるようにするには、ゲームマネージャクラスでアクターの作成を管理するほうが便利です。そこで、`Main.cpp`にあるタイガーI戦車とT-34戦車を作成するプログラムを、ゲームマネージャクラスのメンバ関数にします。

関数名は`SpawnPlayer`(スポーン・プレイヤー)と`SpawnEnemies`(スポーン・エネミーズ)とします。ゲームマネージャクラスに次のプログラムを追加してください。

```diff
   GameManager(const GameManager&) = delete;
   GameManager& operator=(const GameManager&) = delete;
+
+  void SpanwPlayer();
+  void SpawnEnemies();

   State state = State::start; // 現在の動作状態
   std::shared_ptr<Actor> playerTank;
```

この2つのメンバ関数はプライベートメンバにしています。プライベートメンバ関数の実行タイミングはクラスが完全に制御できるため、正しく動く保証をしやすいからです。

もしこれらのメンバ関数がパブリックメンバだった場合、「どんな状況で呼び出されても正常に動作する」ような関数として定義しなくてはなりません。そうしないとバグの元になります。

>「コメントに呼び出すべきタイミングを書いておく」という方法もあります。でも、あなたはコメントを最後まで読んでいますか？　あなたが読んでいないなら、将来この関数を使うであろう「誰か」(または「未来のあなた」)もコメントを読まないでしょう。

続いて、スポーンプレイヤー関数を定義します。`GameManager.cpp`を開き、アップデート関数の定義の下に、次のプログラムを追加してください。

```diff
+
+/**
+* プレイヤーの戦車を生成する
+*/
+void GameManager::SpawnPlayer()
+{
+  // 以前のタイガーI戦車を削除
+  if (playerTank) {
+    playerTank->isDead = true;
+  }
+
+  // 新しいタイガーI戦車を作成
+}
```

次に`Main.cpp`を開き、タイガーI戦車を作成するプログラムを切り取ってください。

```diff
   actors.push_back(std::shared_ptr<Actor>(new Actor{ "Cube", primitiveBuffer.Get(3),
     texTriangle, glm::vec3(0, 0, -4), glm::vec3(1), 0.0f, glm::vec3(0) }));
-
-  // 戦車のパラメータ
-  std::shared_ptr<Actor> playerTank(new PlayerActor{ glm::vec3(0), glm::vec3(1), 0.0f });
-  actors.push_back(playerTank);

   // T-34戦車のパラメータ
```

`GameManager.cpp`を開き、切り取ったプログラムをスポーンプレイヤー関数に貼り付けてください。

```diff
     playerTank->isDead = true;
   }

   // 新しいタイガーI戦車を作成
+
+  // 戦車のパラメータ
+  std::shared_ptr<Actor> playerTank(new PlayerActor{ glm::vec3(0), glm::vec3(1), 0.0f });
+  actors.push_back(playerTank);
 }
```

そして、貼り付けたプログラムをメンバ変数の`playerTank`を使うように修正します。貼り付けたプログラムを次のように変更してください。

```diff
   // 新しいタイガーI戦車を作成
-
-  // 戦車のパラメータ
-  std::shared_ptr<Actor> playerTank(new PlayerActor{ glm::vec3(0), glm::vec3(1), 0.0f });
+  playerTank.reset(new PlayerActor{ glm::vec3(0), glm::vec3(1), 0.0f });
+
-  actors.push_back(playerTank);
+  // タイガーI戦車をゲームエンジンに登録
+  GameEngine::Get().AddActor(playerTank);
 }
```

<div style="page-break-after: always"></div>

### 3.6 ゲームマネージャでT-34戦車を作成する

次はスポーンエネミーズ関数を定義します。スポーンプレイヤー関数の定義の下に、次のプログラムを追加してください。

```diff
   // タイガーI戦車をゲームエンジンに登録
   GameEngine::Get().AddActor(playerTank);
 }
+
+/**
+* 敵戦車を生成
+*/
+void GameManager::SpawnEnemies()
+{
+  GameEngine& engine = GameEngine::Get();
+
+  // 以前に作成したT-34戦車を削除
+  for (int i = 0; i < enemies.size(); ++i) {
+    if (enemies[i]) {
+      enemies[i]->isDead = true;
+    }
+  }
+  enemies.clear();
+
+  // 課題10: 新しいT-34戦車を作成
+
+  // T-34戦車をゲームエンジンに登録
+  for (int i = 0; i < enemies.size(); ++i) {
+    engine.AddActor(enemies[i]);
+  }
+}
```

<pre class="tnmai_assignment">
<strong>【課題10】</strong>
<code>Main.cpp</code>からT-34戦車を作成するプログラムを切り取り、スポーンエネミーズ関数の「新しいT-34戦車を作成」というコメントの下に貼り付けなさい。
</pre>

<pre class="tnmai_assignment">
<strong>【課題11】</strong>
課題10で貼り付けたプログラムについて、すべてのT-34戦車を<code>enemies</code>配列に
<code>push_back</code>するプログラムを追加しなさい。
</pre>

<div style="page-break-after: always"></div>

### 3.7 アップデート関数を完成させる

追加したメンバ変数とメンバ関数を使って、アップデート関数を完成させましょう。アップデート関数を次のように変更してください。

```diff
   switch (state) {
   case State::start:
+    SpawnPlayer();
+    SpawnEnemies();
     state = State::playing;
     std::cout << __func__ << ": start -> playing\n";
     break;
 
   case State::playing:
-    if (/*タイガーI戦車が死んでいる？*/) {
+    if (playerTank->isDead) {
       state = State::gameover;
       std::cout << __func__ << ": playing -> gameover\n";
     }
     else {
+      int surviverCount = 0;
+      for (int i = 0; i < enemies.size(); ++i) {
+        if (enemies[i] && !enemies->isDead) {
+          ++surviverCount;
+        }
+      }
-      if (/*T-34戦車が全滅している？*/) {
+      if (surviverCount <= 0) {
         state = State::gameclear;
         std::cout << __func__ << ": playing -> gameclear\n";
```

これでアップデート関数は完成です。

### 3.8 ゲームマネージャを使う

それではゲームマネージャを使ってゲームの動作状態を管理してみましょう。`Main.cpp`を開き、次のプログラムを追加してください。

```diff
 #include "Texture.h"
 #include "Sampler.h"
 #include "Actor.h"
+#include "GameManager.h"
 #include "Actor/PlayerActor.h"
 #include "Actor/T34TankActor.h"
```

次に、メインループの手前にゲームマネージャを作成するプログラムを追加してください。

```diff
   // 立方体のパラメータ
   actors.push_back(std::shared_ptr<Actor>(new Actor{ "Cube", primitiveBuffer.Get(3),
     texTriangle, glm::vec3(0, 0, -4), glm::vec3(1), 0.0f, glm::vec3(0) }));
+
+  // ゲームマネージャを作成
+  GameManager::Initialize();
+  GameManager& manager = GameManager::Get();

   // メインループ.
   double loopTime = engine.GetTime();  // 1/60秒間隔でループ処理するための時刻
```

次にゲームマネージャのアップデート関数を呼び出します。アップデート関数はゲームの動作状態を常に監視しなくてはならないので、アクターの更新プログラムの直後に実行します。アクターの状態を更新する`for`の下に、次のプログラムを追加してください。

```diff
         // アクターの位置を更新する
         actors[i]->position += actors[i]->velocity * deltaTime;
       }

+      manager.Update(deltaTime);
       GameEngine::Get().UpdateActors();

       // 衝突情報の配列を用意する
```

最後にゲームマネージャを終了します。メインループの下に次のプログラムを追加してください。

```diff
     engine.SwapBuffers();
   }

+  GameManager::Finalize();
   GameEngine::Finalize();

   return 0;
```

これでゲームマネージャによってゲームの動作状態が管理できるようになりました。プログラムが書けたらビルドして実行してください。タイガーI戦車が破壊されたり、T-34戦車を全滅させたとき、コンソールウィンドウに動作状態の変化を示すメッセージが表示されたら成功です。

ゲームクリアやゲームオーバーになったあと、`Enter`キーを押して新しいゲームが始められることも確認してください。

### 3.9 テキスト画像を準備する

「コンソールウィンドウを見ないとゲームの動作状態が分からない」というのは不便ですし、ゲームとしても不親切です。そこで、動作状態に応じた文章を表示しましょう。

ただし、OpenGLには文章を表示する機能がありません。そのため、文章を画像として作成し、その画像をテクスチャとして表示する、という方法が使われます。

画像はPhotoShopやBlenderのような画像編集ソフトで作成します。Visual Studioで作成することも可能ですが、あまり凝ったデザインは作れません。こういうときは、オンラインのロゴ作成サイトが便利です。ウェブブラウザを開き、以下のURLのサイトを開いてください。

>`ja.cooltext.com`

すると以下のページが表示されると思います。

<p align="center">
<img src="images/12_cooltext_top.png" width="50%" /><br>
</p>

まずは「ロゴスタイルを選択してください」の下に表示されている様々なスタイルから、好きなスタイルをクリックしてください。すると以下のような画面に変わります。

<p align="center">
<img src="images/12_cooltext_generator.png" width="50%" /><br>
</p>

最初に選択されているフォントは日本語フォントではないので、フォント画像をクリックしてフォントの選択画面を表示します。使いたいフォントをクリックすると、そのフォントが選択されて前の画面に戻ります。

<p align="center">
<img src="images/12_cooltext_fontlist.png" width="50%" /><br>
</p>

フォントを選択したら、「ロゴテキスト」欄にゲームの目的を入力してください(①)。

<p align="center">
<img src="images/12_cooltext_logotext.png" width="50%" /><br>
</p>

すると、ロゴ画像が入力テキストのとおりに変更されます。文字色を変更したい場合は`Logo`
タブで変更できます(②)。影の見た目を調整したい場合は`Shadow`タブで変更できます(③)。

表示されるタブの種類と変更可能なパラメータはスタイルごとに異なります。いろいろ試してみるとよいでしょう。ロゴが完成したら、`Create Logo`ボタンをクリックしてください。

<p align="center">
<img src="images/12_cooltext_createlogo.png" width="50%" /><br>
</p>

左端の「画像をダウンロード」という文字をクリックすると「名前を付けて保存」ウィンドウが開きます。ファイル名を`GameStart.png`にして、プロジェクトの`Res`フォルダに保存してください。

<p align="center">
<img src="images/12_cooltext_download.png" width="50%" /><br>
</p>

<pre class="tnmai_assignment">
<strong>【課題12】</strong>
保存した<code>GameStart.png</code>をVisual Studioで開き、メニューバーの「ファイル→名前を付けてGameStart.pngを保存」を選択して、<code>TGA</code>形式の画像として保存しなさい。
</pre>

### 3.10 テキスト画像を表示する

作成したテキスト画像を表示するために、板モデルを追加します。プロジェクトの`Res`フォルダに`Plane.obj`(プレーン・オブジェ)というファイルを追加してください。追加したファイルを開き、次のテキストを追加してください。

```diff
+v -0.5 -0.5  0.0
+v  0.5 -0.5  0.0
+v  0.5  0.5  0.0
+v -0.5  0.5  0.0
+
+vt 0.0 0.0
+vt 1.0 0.0
+vt 1.0 1.0
+vt 0.0 1.0
+
+vn  0.0  0.0 -1.0
+
+f 1/1/1 2/2/1 3/3/1
+f 3/3/1 4/4/1 1/1/1
```

>「項目の種類」を「テキスト」に変更することを忘れないように。

<pre class="tnmai_assignment">
<strong>【課題13】</strong>
<code>AddFromObjFile</code>メンバ関数を使って<code>Plane.obj</code>をプリミティブバッファに読み込むプログラムを追加しなさい。
</pre>

それではテキストを表示しましょう。`GameManager.cpp`を開き、アップデート関数に次のプログラムを追加してください。

```diff
   case State::start:
     SpawnPlayer();
     SpawnEnemies();
+
+    { // ゲーム開始メッセージを表示する
+      std::shared_ptr<Actor> gamestart(new Actor{"GameStart",
+        engine.GetPrimitive("Res/Plane.obj"),
+        engine.LoadTexture("Res/GameStart.tga"),
+        glm::vec3(0, 5, 0), glm::vec3(20.0f, 4.0f, 1.0f), 0.0f, glm::vec3(0) });
+      gamestart->lifespan = 3;
+      gamestart->isStatic = true;
+      engine.AddActor(gamestart);
+    }
     state = State::playing;
     std::cout << __func__ << ": start -> playing\n";
```

プログラムが書けたらビルドして実行してください。ゲーム開始時にテキスト画像が表示されていたら成功です。

>**【3章のまとめ】**<br>
>
>* ゲームの進行状態をクラスとしてまとめると、進行状態を管理しやすくなる。
>* 進行状態は列挙型などで表すことができる。

<div style="page-break-after: always"></div>

## 4. UI(ユーザー・インターフェイス)表示

### 4.1 UI表示用のプログラムパイプラインを追加する

テキスト画像は、他のモデルと同じ方法で表示しています。そのため、画面に対して斜めになっていたり、ライトの影響を受けて本来の色ではなくなってしまっています。

テキスト画像の表示を、他のモデルとは違う表示方法を使うことで、遊んでいる人にゲームの動作状態が伝わりやすくしましょう。具体的には、テキスト画像などのUI要素を`Simple.vert`
と`Simple.frag`の2つのシェーダーで描画するようにします。

まずUI表示用のグラフィックスパイプラインとサンプラーを準備します。`GameEngine.h`を開き、ゲームエンジンクラスに次のプログラムを追加してください。

```diff
   GLFWwindow* window = nullptr;
   glm::vec2 windowSize = glm::vec2(0);
+  std::shared_ptr<ProgramPipeline> pipelineUI;
+  std::shared_ptr<Sampler> samplerUI;
   ActorList actors;
   ActorList newActors;
```

次に`GameEngine.cpp`を開き、イニシャライズ関数に次のプログラムを追加してください。

```diff
     int w, h;
     glfwGetWindowSize(window, &w, &h);
     engine->windowSize = glm::vec2(w, h);
+
+    engine->pipelineUI.reset(new ProgramPipeline("Res/Simple.vert", "Res/Simple.frag"));
+    engine->samplerUI.reset(new Sampler(GL_CLAMP_TO_EDGE));

     engine->actors.reserve(1000);
     engine->newActors.reserve(1000);
```

### 4.2 表示レイヤーを定義する

次に、アクターが3DモデルなのかUIなのかを判定する機能を追加します。`Actor.h`を開き、
`Box`構造体の定義の下に次のプログラムを追加してください。

```diff
   glm::vec3 min = glm::vec3(0);
   glm::vec3 max = glm::vec3(0);
 };
+
+/**
+* 表示レイヤー
+*/
+enum class Layer
+{
+  Default,
+  UI,
+};
+
+// レイヤー数(Layer列挙型の要素数)
+static const size_t layerCount = 2;

 /**
 * 物体を制御するパラメータ.
```

次にアクタークラスに次のプログラムを追加してください。

```diff
   float friction = 0.7f;           // 摩擦係数
   bool isStatic = false;           // false=動かせる物体 true=動かせない物体 
+
+  Layer layer = Layer::Default;    // 表示レイヤー
 };

 void Draw(
```

レイヤーを指定することで、アクターの描画方法を選択できるようにしています。

### 4.3 アクターズ変数を配列にする

アクターズ変数を配列にして、レイヤーごとのアクターを管理できるようにします。`GameEngine.h`を開き、ゲームエンジンクラスの定義を次のように変更してください。

```diff
   GLFWwindow* window = nullptr;
   glm::vec2 windowSize = glm::vec2(0);
-  ActorList actors;    // アクター配列
+  ActorList actors[layerCount]; // アクター配列
   ActorList newActors; // 追加するアクターの配列
   std::shared_ptr<PrimitiveBuffer> primitiveBuffer; // プリミティブ配列
```

ここは`std::vector`ではなく通常の配列にしてみました。要素数が100個以下かつ要素数が変更されない場合、通常の配列のほうが扱いやすいことがあります。好みで`std::vector`
に変更しても問題はありません。

`std::vector`に変更する場合、`resize`メンバ関数または初期値によって要素数を指定することを忘れないでください。

次に、アクターの配列を返すゲットアクターズ関数を配列に対応させます。ゲットアクターズ関数の定義を次のように変更してください。

```diff
   static void Finalize();
   static GameEngine& Get();

-  ActorList& GetActors() { return actors; }
+  ActorList& GetActors(Layer layer = Layer::Default)
+  {
+    return actors[static_cast<int>(layer)];
+  }
   void AddActor(std::shared_ptr<Actor> actor) { newActors.push_back(actor); }
   void UpdateActors();
```

続いて、アクターズ変数の初期化を配列に対応させます。`GameEngine.cpp`を開き、イニシャライズ関数のアクターズ変数の初期化を、次のように変更してください。

```diff
     if (!engine) {
       return false;
     }
 
-    engine->actors.reserve(1000);
+    for (int layer = 0; layer < layerCount; ++layer) {
+      engine->actors[layer].reserve(1000);
+    }
     engine->newActors.reserve(1000);
     engine->primitiveBuffer.reset(new PrimitiveBuffer(1'000'000, 4'000'000));
```

### 4.3 アクター更新プログラムをメンバ関数にする

レイヤーに対応させるついでに、`Main.cpp`にあるアクターの更新プログラムをゲームエンジンクラスのメンバ関数にします。メンバ変数に関する処理はメンバ関数で行うべきだからです。

`GameEngine.h`を開き、ゲームエンジンクラスの定義を次のように変更してください。

```diff
   void AddActor(std::shared_ptr<Actor> actor) { newActors.push_back(actor); }
-  void UpdateActors();
+  void UpdateActors(float deltaTime);
+  void PostUpdateActors();

   PrimitiveBuffer& GetPrimitiveBuffer() { return *primitiveBuffer; }
   const Primitive& GetPrimitive(int n) { return primitiveBuffer->Get(n); }
```

`Post`は「～の後」を意味する<ruby>接頭辞<rt>せっとうじ</rt></ruby>(単語の前に付けて意味を修飾する語)です。ここでは「アップデートアクターズの後(に実行する関数)」のような意味で使っています。

次に`GameEngine.cpp`を開き、アップデートアクターズ関数を次のように変更してください。

```diff
 * ゲームエンジンを更新する
 */
-void GameEngine::UpdateActors()
+void GameEngine::UpdateActors(float deltaTime)
+{
+}
+
+/**
+* ゲームエンジンを更新する(後処理)
+*/
+void GameEngine::PostUpdateActors()
 {
   // 新規に作成されたアクターをアクター配列に追加する
```

元のアップデートアクターズ関数をポストアップデートアクターズ関数に改名し、新しく引数付きのアップデートアクターズ関数を作成しています。続いて`Main.cpp`を開き、アクターを更新するプログラムを切り取ってください。

```diff
     for (; diffLoopTime >= deltaTime; diffLoopTime -= deltaTime) {

-      // アクターの状態を更新する
-      for (int i = 0; i < actors.size(); ++i) {
-        // アクターの寿命を減らす
-        if (actors[i]->lifespan > 0) {
-          actors[i]->lifespan -= deltaTime;
-               ・
-               ・
-               ・
-        // アクターの位置を更新する
-        actors[i]->position += actors[i]->velocity * deltaTime;
-      }

      manager.Update(deltaTime);
      GameEngine::Get().UpdateActors();
```

切り取ったプログラムを`GameEngine.cpp`のアップデートアクターズ関数に貼り付けてください。

```diff
 void GameEngine::UpdateActors(float deltaTime)
 {
+      // アクターの状態を更新する
+      for (int i = 0; i < actors.size(); ++i) {
+        // アクターの寿命を減らす
+        if (actors[i]->lifespan > 0) {
+          actors[i]->lifespan -= deltaTime;
+               ・
+               ・
+               ・
+        // アクターの位置を更新する
+        actors[i]->position += actors[i]->velocity * deltaTime;
+      }
 }

 /**
 * ゲームエンジンを更新する(後処理)
```

そして、アクターズ変数をレイヤーに対応させます。貼り付けたプログラムの前後に、次のプログラムを追加してください。

```diff
 void GameEngine::UpdateActors(float deltaTime)
 {
+  for (int layer = 0; layer < layerCount; ++layer) {
+    ActorList& actors = this->actors[layer];
+
     // アクターの状態を更新する
     for (int i = 0; i < actors.size(); ++i) {
       // アクターの寿命を減らす
       if (actors[i]->lifespan > 0) {
         actors[i]->lifespan -= deltaTime;
              ・
              ・
              ・
       // アクターの位置を更新する
       actors[i]->position += actors[i]->velocity * deltaTime;
     }
+  }
 }

 /**
 * ゲームエンジンを更新する(後処理)
```

次に、ポストアップデート関数をレイヤーに対応させます。ポストアップデートアクターズ関数に次のプログラムを追加してください。

```diff
 void GameEngine::PostUpdateActors()
 {
   // 新規に作成されたアクターをアクター配列に追加する
   for (int i = 0; i < newActors.size(); ++i) {
-    actors.push_back(newActors[i]);
+    const int layer = static_cast<int>(newActors[i]->layer);
+    if (layer >= 0 && layer < layerCount) {
+      actors[layer].push_back(newActors[i]);
+    }
   }
 
   // 新規アクター配列を空にする
```

最後に`Main.cpp`を開き、ゲーム状態を更新する`for`の先頭部分を次のように変更してください。

```diff
     // ゲーム状態を更新する
     //

     for (; diffLoopTime >= deltaTime; diffLoopTime -= deltaTime) {
-
-
+      engine.UpdateActors(deltaTime);
       manager.Update(deltaTime);
-      GameEngine::Get().UpdateActors();
+      engine.PostUpdateActors();

       // アクターの衝突判定を行う
       std::vector<Contact> contacts;
```

### 4.4 UI描画関数を追加する

ここまででUI表示用の部品が揃ったので、ゲームエンジンクラスにUIを描画する関数を追加します。関数名は`RenderUI`(レンダー・ユー・アイ)とします。`GameEngine.h`を開き、次のプログラムを追加してください。

```diff
   void AddActor(std::shared_ptr<Actor> actor) { newActors.push_back(actor); }
   void UpdateActors();
+  void RenderUI();

   PrimitiveBuffer& GetPrimitiveBuffer() { return *primitiveBuffer; }
   const Primitive& GetPrimitive(int n) { return primitiveBuffer->Get(n); }
```

次に`GameManager.cpp`を開き、アップデートアクターズ関数の定義の下に、次のプログラムを追加してください。

```diff
   // 新規アクター配列を空にする
   newActors.clear();
 }
+
+/**
+* UIアクターを描画する
+*/
+void GameEngine::RenderUI()
+{
+  glDisable(GL_DEPTH_TEST);
+  glDisable(GL_CULL_FACE);
+  glEnable(GL_BLEND);
+  glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+
+  primitiveBuffer->BindVertexArray();
+  pipelineUI->Bind();
+  samplerUI->Bind(0);
+
+  // プロジェクション行列を作成.
+  const glm::vec2 halfSize = windowSize * 0.5f;
+  const glm::mat4 matProj = glm::ortho(
+    -halfSize.x, halfSize.x, -halfSize.y, halfSize.y, 1.0f, 200.0f);
+
+  // ビュー行列を作成.
+  const glm::mat4 matView = glm::lookAt(
+    glm::vec3(0, 0, 1), glm::vec3(0), glm::vec3(0, 1, 0));
+
+  // 2Dアクターを描画する

+  const ActorList& a = actors[static_cast<int>(Layer::UI)];
+  for (int i = 0; i < a.size(); ++i) {
+    Draw(*a[i], *pipelineUI, matProj, matView);
+  }
+
+  pipelineUI->Unbind();
+  samplerUI->Unbind(0);
+  primitiveBuffer->UnbindVertexArray();
+}

 /**
 * 名前の一致するプリミティブを取得する
```

一般的にUIは手前に置いても奥に置いても大きさは同じです。奥行きによって大きさを変えたくない場合、プロジェクション行列の作成に`orth`(オルソ)関数を使います。

<pre class="tnmai_code"><strong>【書式】</strong><code>
プロジェクション行列 glm::orth(表示範囲の左端, 右端, 表示範囲の下端, 上端, 表示範囲の最小Z値, 最大Z値);
</code></pre>

それと、UI表示に使う`Simple.vert`にはモデル行列用のユニフォーム変数が存在しないため、行列をGPUメモリにコピーしようとするとエラーになります。そこで、UI描画の場合はモデル行列を設定しないようにします。`Actor.cpp`を開き、ドロー関数を次のように変更してください。

```diff
   const GLint locMatTRS = 0;
   const GLint locMatModel = 1;
   pipeline.SetUniform(locMatTRS, matMVP);
+  if (actor.layer == Layer::Default) {
     pipeline.SetUniform(locMatModel, matModel);
+  }

   if (actor.tex) {
     actor.tex->Bind(0); // テクスチャを割り当てる
```

最後に、作成したUI描画関数を呼び出します。`Main.cpp`を開き、アクターを描画するプログラムの下に、次のプログラムを追加してください。

```diff
     for (int i = 0; i < actors.size(); ++i) {
       Draw(*actors[i], pipeline, matProj, matView);
     }
+    engine.RenderUI();

     // テクスチャの割り当てを解除.
     glActiveTexture(GL_TEXTURE0);
```

これでUI描画の準備ができました。ゲーム開始時のテキスト画像のレイヤーをUIに変更しましょう。`GameManager.cpp`を開き、テキスト画像を表示するプログラムに次のプログラムを追加してください。

```diff
       std::shared_ptr<Actor> gamestart(new Actor{"GameStart",
         engine.GetPrimitive("Res/Plane.obj"),
         engine.LoadTexture("Res/GameStart.tga"),
-        glm::vec3(0, 5, 0), glm::vec3(20.0f, 4.0f, 1.0f), 0.0f, glm::vec3(0) });
+        glm::vec3(0, 0, 0), glm::vec3(800.0f, 200.0f, 1.0f), 0.0f, glm::vec3(0) });
+      gamestart->layer = Layer::UI;
       gamestart->lifespan = 3;
       gamestart->isStatic = true;
```

UI描画では、画面サイズと等しい大きさの座標系を使います。本テキストでは画面サイズを1280x720としているので、X軸の範囲は±640、Y軸の範囲±360になります。画面の中心は常に(0, 0)です。

プログラムが書けたらビルドして実行してください。テキスト画像がライトの影響を受けずに表示されていたら成功です。

<pre class="tnmai_assignment">
<strong>【課題14】</strong>
GameStartアクターの拡大率XとYの比率について、テキスト画像の縦横比と等しくなる、つまり「拡大率X:拡大率Y = 画像の幅:画像の高さ」となるように、拡大率の値を変更しなさい。
</pre>

### 4.5 UIアクターを削除する

GameStartアクターのライフスパンは`3`ですが、3秒たっても表示が消えなくなっています。これはデフォルトレイヤーのアクターしか削除していないためです。そこで、全てのレイヤーのアクターが削除されるようにしましょう。

`GameEngine.h`を開き、次のプログラムを追加してください。

```diff
   void AddActor(std::shared_ptr<Actor> actor) { newActors.push_back(actor); }
   void UpdateActors();
+  void RemoveDeadActors();
   void RenderUI();
```

次に`GameEngien.cpp`を開き、アップデートアクターズ関数の定義の下に、次のプログラムを追加してください。

```diff
   // 新規アクター配列を空にする
   newActors.clear();
 }
+
+/**
+* 削除待ちのアクターを削除する
+*/
+void GameEngine::RemoveDeadActors()
+{
+  for (int layer = 0; layer < layerCount; ++layer) {
+    ActorList& a = actors[layer];
+    a.erase(std::remove_if(a.begin(), a.end(),
+      [](std::shared_ptr<Actor>& actor) { return actor->isDead; }),
+      a.end());
+  }
+}

 /**
 * UIアクターを描画する
```

`for`を使うことで、全てのレイヤーの削除待ちアクターを削除しています。`Main.cpp`を開き「削除待ちアクターを削除する」プログラムを、次のように変更してください。

```diff
         SolveContact(contacts[i]);
       }

       // 削除待ちのアクターを削除する
-      actors.erase(
-        std::remove_if(actors.begin(), actors.end(),
-          [](std::shared_ptr<Actor>& a) { return a->isDead; }),
-        actors.end());
+      engine.RemoveDeadActors();

       // カメラデータを更新する
       {
```

プログラムが書けたらビルドして実行してください。3秒でテキスト画像が消えたら成功です。

<pre class="tnmai_assignment">
<strong>【課題15】</strong>
ゲームクリアを表すテキスト画像を作成し、ゲームクリアになったとき時に表示しなさい。
</pre>

<pre class="tnmai_assignment">
<strong>【課題16】</strong>
ゲームオーバーを表すテキスト画像を作成し、ゲームオーバーになった時に表示しなさい。
</pre>

<p align="center">
<img src="images/12_result_0.png" width="45%" /><br>
</p>

>**【4章のまとめ】**<br>
>
>* UIのような2D画像を表示する場合、`glm::ortho`関数て作成したパースペクティブ行列を使う。
>* 表示座標は`glm::ortho`に指定した範囲に依存するので、実際の画面サイズを範囲に指定するとよい。
>* 3DアクターとUIアクターで表示方法を切り替えるために、アクター配列を分けておくとよい。
